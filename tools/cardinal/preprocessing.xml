<tool id="cardinal_preprocessing" name="MSI preprocessing" version="@VERSION@.0">
    <description>
        mass spectrometry imaging preprocessing
    </description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements">
        <requirement type="package" version="2.3">r-gridextra</requirement>
        <requirement type="package" version="4.0.0">r-ggplot2</requirement>
        <requirement type="package" version="3.54.0">bioconductor-sva</requirement>
        <requirement type="package" version="1.1.0.1">r-randomcolor</requirement>
    </expand>
    <command detect_errors="exit_code">
    <![CDATA[

        @INPUT_LINKING@
        cat '${cardinal_preprocessing}' &&
        Rscript '${cardinal_preprocessing}' &&

        mkdir $outfile_imzml.files_path &&
            mv ./out.imzML "${os.path.join($outfile_imzml.files_path, 'imzml')}" | true &&
            mv ./out.ibd "${os.path.join($outfile_imzml.files_path, 'ibd')}" | true &&
        echo "imzML file:" > $outfile_imzml &&
        ls -l "$outfile_imzml.files_path" >> $outfile_imzml

    ]]>
    </command>
    <configfiles>
        <configfile name="cardinal_preprocessing"><![CDATA[

################################# load libraries and read file #################

## set CPU, default = 1

if (Sys.getenv("GALAXY_SLOTS")!="")
    {
        number_cpu = 1 ## default = 1
    }else{
        number_cpu = as.numeric(Sys.getenv("GALAXY_SLOTS")) ##cpu set by Galaxy
    }

library(Cardinal)
library(gridExtra)
library(ggplot2)
library(sva)
library(randomcoloR)


@READING_MSIDATA_FULLY_COMPATIBLE@


## remove duplicated coordinates, otherwise peak picking and log2 transformation will fail

## set variable to False
#set $used_peak_picking = False
#set $used_peak_alignment = False
#set $continuous_format = False


###if (ncol(msidata)>0 & nrow(msidata) >0){

    ## start QC report

    pdf("Preprocessing.pdf", fonts = "Times", pointsize = 12)
    plot(0,type='n',axes=FALSE,ann=FALSE)
    title(main=paste("Quality control during preprocessing \n", "Filename:", "$infile.display_name"))

    ######################### preparations for QC report #################

    #if $infile.ext == 'imzml'
            #if str($processed_cond.processed_file) == "processed":

                ## Max number of features (mz) = number of features from array with max features
                maxfeatures = max(msidata@spectraData@data@listData[["mz"]]@dim)

                ## Range mz
                mz_list = msidata@spectraData@data@listData[["mz"]]
                mz_list_extracted = as.list(mz_list)
                mz_values = unlist(lapply(mz_list_extracted, as.numeric))
                min_value = min(mz_values, na.rm = TRUE)
                minmz = round(min_value, digits=2)
                max_value = max(mz_values, na.rm = TRUE)
                maxmz = round(max_value, digits=2)

                pixelcount = length(pixels(msidata))

                QC_numbers= data.frame(inputdata = c(minmz, maxmz, maxfeatures, pixelcount))
                vectorofactions = "inputdata"
                ## Choose random spectra for QC plots
                random_spectra = sample(pixels(msidata), 4, replace=FALSE)
                par(mfrow=c(2,2))
                par(oma=c(0,0,2,0))
                print(plot(msidata, i=random_spectra, col="black"))
                title("Input spectra", outer=TRUE, line=0)

            #else
                maxfeatures =nrow(msidata)
                pixelcount = ncol(msidata)
                minmz = round(min(mz(msidata)), digits=2)
                maxmz = round(max(mz(msidata)), digits=2)
                QC_numbers= data.frame(inputdata = c(minmz, maxmz,maxfeatures, pixelcount))
                vectorofactions = "inputdata"
                ## Choose random spectra for QC plots
                random_spectra = sample(pixels(msidata), 4, replace=FALSE)
                par(mfrow=c(2,2))
                par(oma=c(0,0,2,0))
                print(plot(msidata, i=random_spectra, col="black"))
                title("Input spectra", outer=TRUE, line=0)

            #end if
    #end if

    ############################### Preprocessing steps ###########################
    ###############################################################################

    #for $method in $methods:

    ############################### Normalization ###########################

        #if str( $method.methods_conditional.preprocessing_method ) == 'Normalization':
            print('Normalization')
            ##normalization

            msidata = normalize(msidata, method="$method.methods_conditional.methods_for_normalization.normalization_method")
            msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))


            ############################### QC ###########################

            #if $infile.ext == 'imzml'
                #if str($processed_cond.processed_file) == "processed":

                    ## Max number of features (mz) = number of features from array with max features
                    maxfeatures = max(msidata@spectraData@data@listData[["mz"]]@dim)

                    ## Range mz
                    mz_list = msidata@spectraData@data@listData[["mz"]]
                    mz_list_extracted = as.list(mz_list)
                    mz_values = unlist(lapply(mz_list_extracted, as.numeric))
                    min_value = min(mz_values, na.rm = TRUE)
                    minmz = round(min_value, digits=2)
                    max_value = max(mz_values, na.rm = TRUE)
                    maxmz = round(max_value, digits=2)

                    pixelcount = length(pixels(msidata))

                    normalized = c(minmz, maxmz, maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, normalized)
                    vectorofactions = append(vectorofactions, "normalized")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after normalization", outer=TRUE, line=0)

                #else
                    maxfeatures =nrow(msidata)
                    pixelcount = ncol(msidata)
                    minmz = round(min(mz(msidata)), digits=2)
                    maxmz = round(max(mz(msidata)), digits=2)
                    normalized = c(minmz, maxmz, maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, normalized)
                    vectorofactions = append(vectorofactions, "normalized")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after normalization", outer=TRUE, line=0)

                #end if
            #end if

    ############################### Baseline reduction ###########################

        #elif str( $method.methods_conditional.preprocessing_method ) == 'Baseline_reduction':
            print('Baseline_reduction')
            ##baseline reduction

            msidata = reduceBaseline(msidata, method="$method.methods_conditional.baseline_method")
            msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            ############################### QC ###########################

            #if $infile.ext == 'imzml'
                #if str($processed_cond.processed_file) == "processed":

                    ## Max number of features (mz) = number of features from array with max features
                    maxfeatures = max(msidata@spectraData@data@listData[["mz"]]@dim)

                    ## Range mz
                    mz_list = msidata@spectraData@data@listData[["mz"]]
                    mz_list_extracted = as.list(mz_list)
                    mz_values = unlist(lapply(mz_list_extracted, as.numeric))
                    min_value = min(mz_values, na.rm = TRUE)
                    minmz = round(min_value, digits=2)
                    max_value = max(mz_values, na.rm = TRUE)
                    maxmz = round(max_value, digits=2)

                    pixelcount = length(pixels(msidata))

                    baseline = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, baseline)
                    vectorofactions = append(vectorofactions, "baseline")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after baseline reduction", outer=TRUE, line=0)

                #else
                    maxfeatures =nrow(msidata)
                    pixelcount = ncol(msidata)
                    minmz = round(min(mz(msidata)), digits=2)
                    maxmz = round(max(mz(msidata)), digits=2)
                    baseline = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, baseline)
                    vectorofactions = append(vectorofactions, "baseline")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after baseline reduction", outer=TRUE, line=0)

                #end if
            #end if

    ############################### Smoothing ###########################

        #elif str( $method.methods_conditional.preprocessing_method ) == 'Smoothing':
            print('Smoothing')
            ## Smoothing

            #if str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'gaussian':
                print('gaussian smoothing')

                msidata = smooth(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", width = $method.methods_conditional.methods_for_smoothing.width_gaussian, sd =$method.methods_conditional.methods_for_smoothing.sd_gaussian)
                msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            #elif str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'sgolay':
                print('sgolay smoothing')

                msidata = smooth(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", width = $method.methods_conditional.methods_for_smoothing.width_sgolay, order = $method.methods_conditional.methods_for_smoothing.order_of_filters, deriv = $method.methods_conditional.methods_for_smoothing.deriv_sgolay, delta = $method.methods_conditional.methods_for_smoothing.delta_sgolay)
                msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

                ## if selected replace negative intensities with zero
                #if $method.methods_conditional.methods_for_smoothing.replace_negatives:
                    ## bring spectra matrix to disk
                    spectra_df = as.matrix(spectra(msidata))
                    spectra_df[spectra_df<0] = 0
                    spectra(msidata) = spectra_df
                #end if

            #elif str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'adaptive':
                print('adaptive smoothing')

                msidata = smooth(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method",  width = $method.methods_conditional.methods_for_smoothing.width_adaptive, spar = $method.methods_conditional.methods_for_smoothing.spar_adaptive)
                msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            #elif str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'diff':
                print('diff smoothing')

                msidata = smooth(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", niter = $method.methods_conditional.methods_for_smoothing.niter_diff, kappa = $method.methods_conditional.methods_for_smoothing.kappa_diff, rate = $method.methods_conditional.methods_for_smoothing.rate_diff)
                msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            #elif str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'guide':
                print('guided smoothing')

                msidata = smooth(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", width = $method.methods_conditional.methods_for_smoothing.width_guide)
                msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            #elif str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'pag':
                print('peak-aware guided smoothing')

                msidata = smooth(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", width = $method.methods_conditional.methods_for_smoothing.width_pag, ftol = $method.methods_conditional.methods_for_smoothing.ftol_pag)
                msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            #elif str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'ma':
                print('moving average smoothing')

                msidata = smooth(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", width=$method.methods_conditional.methods_for_smoothing.width_ma)
                msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            #end if

            ############################### QC ###########################

            #if $infile.ext == 'imzml'
                #if str($processed_cond.processed_file) == "processed":

                    ## Max number of features (mz) = number of features from array with max features
                    maxfeatures = max(msidata@spectraData@data@listData[["mz"]]@dim)

                    ## Range mz
                    mz_list = msidata@spectraData@data@listData[["mz"]]
                    mz_list_extracted = as.list(mz_list)
                    mz_values = unlist(lapply(mz_list_extracted, as.numeric))
                    min_value = min(mz_values, na.rm = TRUE)
                    minmz = round(min_value, digits=2)
                    max_value = max(mz_values, na.rm = TRUE)
                    maxmz = round(max_value, digits=2)

                    pixelcount = length(pixels(msidata))

                    smoothed = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, smoothed)
                    vectorofactions = append(vectorofactions, "smoothed")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after smoothing", outer=TRUE, line=0)

                #else
                    maxfeatures =nrow(msidata)
                    pixelcount = ncol(msidata)
                    minmz = round(min(mz(msidata)), digits=2)
                    maxmz = round(max(mz(msidata)), digits=2)
                    smoothed = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, smoothed)
                    vectorofactions = append(vectorofactions, "smoothed")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after smoothing", outer=TRUE, line=0)

                #end if
            #end if


    ############################### Mz recalibration ###########################

        #elif str( $method.methods_conditional.preprocessing_method ) == 'mz_recalibration':
            print('m/z recalibration')
            ## m/z recalibration

            #if str ( $method.methods_conditional.mz_recalibration_reference.reference_type ) == 'estimate_reference':

            reference_mz = estimateReferencePeaks(msidata)

            #elif str ( $method.methods_conditional.mz_recalibration_reference.reference_type ) == 'reference_mz':

            reference_mz = read.delim("$method.methods_conditional.mz_recalibration_reference.mz_tabular", header = $method.methods_conditional.mz_recalibration_reference.feature_header, stringsAsFactors = FALSE)
            reference_mz = reference_mz[,$method.methods_conditional.mz_recalibration_reference.feature_column]

            #end if

            msidata = recalibrate(msidata, ref=reference_mz, method = "$method.methods_conditional.recalibration_method",  tolerance = $method.methods_conditional.recalibration_tolerance, units = "$method.methods_conditional.recalibration_unit")
            msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            ## remove the reference peaks data to allow proper peak alignment afterwards
            #if $infile.ext == 'imzml'
                #if str($processed_cond.processed_file) == "processed":

                #else
                metadata(featureData(msidata))['reference peaks'] <- NULL

                #end if
            #end if

            ############################### QC ###########################

            #if $infile.ext == 'imzml'
                #if str($processed_cond.processed_file) == "processed":

                    ## Max number of features (mz) = number of features from array with max features
                    maxfeatures = max(msidata@spectraData@data@listData[["mz"]]@dim)

                    ## Range mz
                    mz_list = msidata@spectraData@data@listData[["mz"]]
                    mz_list_extracted = as.list(mz_list)
                    mz_values = unlist(lapply(mz_list_extracted, as.numeric))
                    min_value = min(mz_values, na.rm = TRUE)
                    minmz = round(min_value, digits=2)
                    max_value = max(mz_values, na.rm = TRUE)
                    maxmz = round(max_value, digits=2)

                    pixelcount = length(pixels(msidata))

                    mz_recal = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, mz_recal)
                    vectorofactions = append(vectorofactions, "mz_recal")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after m/z recalibration", outer=TRUE, line=0)

                #else
                    maxfeatures =nrow(msidata)
                    pixelcount = ncol(msidata)
                    minmz = round(min(mz(msidata)), digits=2)
                    maxmz = round(max(mz(msidata)), digits=2)
                    mz_recal = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, mz_recal)
                    vectorofactions = append(vectorofactions, "mz_recal")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after m/z recalibration", outer=TRUE, line=0)

                #end if
            #end if

    ############################### Peak picking ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Peak_picking':
            #set $used_peak_picking = True
            print('Peak_picking')
            ## Peakpicking

            msidata = peakPick(msidata, method='$method.methods_conditional.methods_for_picking.picking_method', SNR=$method.methods_conditional.SNR_picking_method, type='$method.methods_conditional.picking_type')

            msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            ############################### QC ###########################

            #if $infile.ext == 'imzml'
                #if str($processed_cond.processed_file) == "processed":

                    ## Max number of features (mz) = number of features from array with max features
                    mz_list <- msidata@spectraData@data@listData[["mz"]]
                    lengths_list <- sapply(mz_list, length)
                    maxfeatures <- max(lengths_list)

                    ## Range mz
                    ###mz_list = msidata@spectraData@data@listData[["mz"]]
                    mz_list_extracted = as.list(mz_list)
                    mz_values = unlist(lapply(mz_list_extracted, as.numeric))
                    min_value = min(mz_values, na.rm = TRUE)
                    minmz = round(min_value, digits=2)
                    max_value = max(mz_values, na.rm = TRUE)
                    maxmz = round(max_value, digits=2)

                    pixelcount = length(pixels(msidata))

                    picked = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, picked)
                    vectorofactions = append(vectorofactions, "picked")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after peak picking", outer=TRUE, line=0)

                #else
                    maxfeatures =nrow(msidata)
                    pixelcount = ncol(msidata)
                    minmz = round(min(mz(msidata)), digits=2)
                    maxmz = round(max(mz(msidata)), digits=2)
                    picked = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, picked)
                    vectorofactions = append(vectorofactions, "picked")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after peak picking", outer=TRUE, line=0)

                #end if
            #end if

    ############################### Peak alignment ###########################

        #elif str( $method.methods_conditional.preprocessing_method ) == 'Peak_alignment':
            #set $used_peak_alignment = True
            print('Peak_alignment')
            ## Peakalignment

            #if str( $method.methods_conditional.align_ref_type.align_reference_datatype) == 'align_table':

                align_reference_table = read.delim("$method.methods_conditional.align_ref_type.mz_tabular", header = $method.methods_conditional.align_ref_type.feature_header, stringsAsFactors = FALSE)

                align_reference_column = align_reference_table[,$method.methods_conditional.align_ref_type.feature_column]

                align_peak_reference = as.numeric(align_reference_column[align_reference_column>=min(mz(msidata)) & align_reference_column<=max(mz(msidata))])
                if (length(align_peak_reference) == 0)
                    {align_peak_reference = 0}

                msidata = peakAlign(msidata, tolerance =$method.methods_conditional.value_diffalignment, units = "$method.methods_conditional.units_diffalignment", ref=align_peak_reference)

            #elif str( $method.methods_conditional.align_ref_type.align_reference_datatype) == 'align_noref':

                msidata = peakAlign(msidata, tolerance =$method.methods_conditional.value_diffalignment, units = "$method.methods_conditional.units_diffalignment")

            #end if

            msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))


            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            aligned = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, aligned)
            vectorofactions = append(vectorofactions, "aligned")
            print(plot(msidata, i=random_spectra, col="black"))
            title("Spectra after alignment", outer=TRUE, line=0)

    ############################### Peak filtering ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Peak_filtering':
            print('Peak_filtering')

            msidata = subsetFeatures(msidata, freq > $method.methods_conditional.frequ_filtering)

            msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            filtered = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, filtered)
            vectorofactions = append(vectorofactions, "filtered")
            print(plot(msidata, i=random_spectra, col="black"))
            title("Spectra after filtering", outer=TRUE, line=0)


    ############################### Peak binning ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Peak_binning':
            print('Peak_binning')

            ## reading reference file
            reference_table = read.delim("$method.methods_conditional.mz_tabular", header = $method.methods_conditional.feature_header, stringsAsFactors = FALSE)
            reference_column = reference_table[,$method.methods_conditional.feature_column]
            peak_reference = reference_column[reference_column>min(mz(msidata)) & reference_column<max(mz(msidata))]

            msidata = peakPick(msidata, ref = peak_reference, tolerance = $method.methods_conditional.peakbin_tol, units = "$method.methods_conditional.peakbin_units", type="$method.methods_conditional.peaks_type")
            msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            peak_binned = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, peak_binned)
            vectorofactions = append(vectorofactions, "peak binned")
            print(plot(msidata, i=random_spectra, col="black"))
            title("Spectra after peak binning", outer=TRUE, line=0)


    ############################### Mass binning ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Mass_binning':
            print('Mass_binning')

            ## spectra binning without reference or change of m/z axis:
            #if str( $method.methods_conditional.mz_range.features_filtering) == 'none':

                msidata <- bin(msidata, resolution=$method.methods_conditional.bin_width, units="$method.methods_conditional.bin_units", method="$method.methods_conditional.bin_method")


            ## spectra binning with reference peaks:
            #elif str( $method.methods_conditional.mz_range.features_filtering) == 'bin_to_reference':

                reference_table = read.delim("$method.methods_conditional.mz_range.mz_tabular", header = $method.methods_conditional.mz_range.feature_header, stringsAsFactors = FALSE)
                reference_column = reference_table[,$method.methods_conditional.mz_range.feature_column]
                bin_reference = reference_column[reference_column>min(mz(msidata)) & reference_column<max(mz(msidata))]

                bin_reference = as.numeric(bin_reference[bin_reference>=min(mz(msidata)) & bin_reference<=max(mz(msidata))])

                if (length(bin_reference) == 0)
                    {bin_reference = 0}

                msidata <- bin(msidata, ref = bin_reference, tolerance=$method.methods_conditional.bin_tolerance, resolution=$method.methods_conditional.bin_width, units="$method.methods_conditional.bin_units", method="$method.methods_conditional.bin_method")


            ## spectra binning with change of m/z axis to min and max m/z values:
            #elif str( $method.methods_conditional.mz_range.features_filtering) == 'change_mz_range':

                msidata = bin(msidata, resolution=$method.methods_conditional.bin_width, tolerance=$method.methods_conditional.bin_tolerance, units="$method.methods_conditional.bin_units", method="$method.methods_conditional.bin_method", mass.range=c($method.methods_conditional.mz_range.min_mz,$method.methods_conditional.mz_range.max_mz))

            #end if

            msidata <- process(msidata, BPPARAM=MulticoreParam(workers=number_cpu))

                
            ## optional: replace NA with 0
            #if $method.methods_conditional.replace_NA_bin:
                ## count and replace NAs
                    print(paste0("Number of NA that were set to zero after binning:", sum(is.na(spectra(msidata)@data))))
                    print(is.na(spectra(msidata)@data))
                    print(msidata)

                    spectra(msidata)[is.na(spectra(msidata))] = 0
            #end if
                
            ############################### QC ###########################

                    maxfeatures =nrow(msidata)
                    pixelcount = ncol(msidata)
                    minmz = round(min(mz(msidata)), digits=2)
                    maxmz = round(max(mz(msidata)), digits=2)
                    reduced = c(minmz, maxmz,maxfeatures, pixelcount)
                    QC_numbers= cbind(QC_numbers, reduced)
                    vectorofactions = append(vectorofactions, "reduced")
                    print(plot(msidata, i=random_spectra, col="black"))
                    title("Spectra after m/z binning", outer=TRUE, line=0)

        ############################### Transformation ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Transformation':
            print('Transformation')

            if (class(msidata) == "MSProcessedImagingExperiment"){
                msidata = as(msidata, "MSContinuousImagingExperiment")
            }


            ## replace 0 with NA to prevent Inf
                spectra_df = as.matrix(spectra(msidata)) ## convert to R matrix
                spectra_df[spectra_df ==0] = NA
                print(paste0("Number of 0 which were converted into NA:",sum(is.na(spectra_df))))
                spectra(msidata) = spectra_df


            #if str( $method.methods_conditional.transf_conditional.trans_type) == 'log2':
                print('log2 transformation')

                ## log transformation
                spectra(msidata) = log2(spectra(msidata))

                print(msidata)

                ## optional: replace NA with 0
                #if $method.methods_conditional.transf_conditional.replace_NA_trans:
                    spectra(msidata)[is.na(spectra(msidata))] = 0
                #end if

            #elif str( $method.methods_conditional.transf_conditional.trans_type) == 'sqrt':
                print('squareroot transformation')

                spectra(msidata) = sqrt(spectra(msidata))

           #end if

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            transformed = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, transformed)
            vectorofactions = append(vectorofactions, "transformed")
            print(plot(msidata, i=random_spectra, col="black"))
            title("Spectra after transformation", outer=TRUE, line=0)

            
        ############################### ComBat batch correction ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'ComBat_batch_correction':
            print('ComBat batch correction of centroided data')

            ## load annotation tabular and define batch and condition column
            annotation = read.delim("$method.methods_conditional.annotation_file", header=$method.methods_conditional.feature_header, sep="\t")
            annotation_x = annotation[,$method.methods_conditional.x_column]
            annotation_y = annotation[,$method.methods_conditional.y_column]
            batch = annotation[,$method.methods_conditional.batch_column]
            condition = annotation[,$method.methods_conditional.condition_column]
            
            ### stop if not enough batches provided
                tryCatch(
                        {

                        if (unique(batch<2))
                            {
                            stop(call.=FALSE)
                            }
                        },
                        error=function(cond) {
                        ## in case user provided an annotation tabular with less than two batches
                            message("Error in annotation tabular")
                            message("Possible problems: Annotation tabular file has not enough batch levels - to perform ComBat at least 2 batches and 2 pixels per batch are necessary)")
                            stop(call.=FALSE)
                        }
                    )
            
            ## get intensity matrix from imzml file
            intensity_matrix = as.matrix(spectra(msidata))
            mz_names = paste0("mz_", mz(msidata))
            pixel_names = paste0("xy_", coord(msidata)\$x, "_", coord(msidata)\$y)
            print(pixel_names[1:5])
            rownames(intensity_matrix) = mz_names
            colnames(intensity_matrix) = pixel_names

            ## reorder columns of intensity matrix to row order of batch column
            rownames(annotation) = paste0("xy_", annotation_x, "_", annotation_y)
            col_order = rownames(annotation)
            
            ### stop if pixel/sample names (columns) in intensity matrix from imzml file don't match samples names (rows) in annotation tabular file            
            	tryCatch(
                        {

                        if (all(colnames(intensity_matrix) %in% col_order == FALSE))
                            {
                            stop(call.=FALSE)
                            }
                        },
                        error=function(cond) {
                        ## in case pixel names (columns) from the imzml file don't match the pixel names in the annotation tabular file
                            message("Error in annotation tabular")
                            message("Possible problems: Annotation tabular file does not contain the correct pixel names (columns) from the imzml file)")
                            stop(call.=FALSE)
                        }
                    )      
            
            intensity_matrix = intensity_matrix[, col_order]
            print("columns have been ordered to annotation row order")

            ## execution of ComBat algorithm from sva package
            combat_data = ComBat(dat = intensity_matrix, batch = batch, mod = NULL, par.prior = TRUE, prior.plots = FALSE)
            print("Combat has been executed")

            ## change intensity data of loaded imzml file after combat has been performed
            spectra(msidata) = as.matrix(combat_data)
            
            ############################### QC ###########################
            
            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            batch_corrected = c(minmz, maxmz, maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, batch_corrected)
            vectorofactions = append(vectorofactions, "batch_corrected")
            print(plot(msidata, i=random_spectra, col="black"))
            title("Spectra after ComBat batch correction", outer=TRUE, line=0)


            ## PCA plot function and execution
	    combat_data = as.data.frame(combat_data)
	    intensity_data = as.data.frame(intensity_matrix)

	    ## PCA function
            plot_PCA = function(input_data, condition, batch, title, color){
                data <- input_data
                pca_data <- prcomp(t(data[, seq_len(ncol(input_data))]))
                pca_sdev <- pca_data[["sdev"]]
                pca_data_perc <- round(100 * pca_sdev^2 / sum(pca_sdev^2), 1)
                pca_components <- pca_data[["x"]]
                df_pca_data <- data.frame(PC1 = pca_components[, 1], PC2 = pca_components[, 2], sample = colnames(input_data), condition = condition)
                ggplot(df_pca_data, aes(PC1, PC2, color = as.factor(batch), shape = as.factor(condition))) +
                ggtitle(title) +
                geom_point(size = 4) +
                stat_ellipse(aes(PC1, PC2, color = as.factor(batch), group = as.factor(batch)), type = "norm")+
                scale_color_manual(values=color) +
                theme_bw() +
                theme(legend.position = "bottom", legend.box="vertical", plot.title = element_text(size = 12, hjust = 0.5), axis.title = element_text(size = 12), axis.text = element_text(size = 12, color = "black")) +
                labs(x=paste0("PC1 (",pca_data_perc[1],")"), y=paste0("PC2 (",pca_data_perc[2],")")) +
                labs(color = "Batches", shape = "Conditions")}

	    ## define colors
	    color_pal = distinctColorPalette(length(levels(as.factor(batch))))

            ## execution of PCA plots
            PCA_bc = plot_PCA(intensity_data, condition, batch, "before batch correction", color_pal)
            PCA_ac = plot_PCA(combat_data, condition, batch, "batch corrected", color_pal)
            print(PCA_bc)
            print(PCA_ac)
            
            #end if
    #end for

    ############# Outputs: RData, imzml and QC report #############
    ################################################################################

    ## save msidata as imzML file, will only work if there is at least 1 m/z left

        ####if (nrow(msidata) > 0){
        if (maxfeatures > 0){
            ## make sure that coordinates are integers
            coord(msidata)\$y = as.integer(coord(msidata)\$y)
            coord(msidata)\$x = as.integer(coord(msidata)\$x)
            ## only continuous files can currently be exported
            ## changed with version 3.6.4: also writing of processed files
            ##msidata = as(msidata, "MSImagingExperiment")
            writeImzML(msidata, "out")
        }

    plot(0,type='n',axes=FALSE,ann=FALSE)
    rownames(QC_numbers) = c("min m/z", "max mz", "# features", "# spectra")
    grid.table(t(QC_numbers))
    dev.off()

###}else{
    print("inputfile has no intensities > 0")
###}

    ]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="reading_msidata"/>
        <repeat name="methods" title="Preprocessing" min="1" max="50">
            <conditional name="methods_conditional">
                <param name="preprocessing_method" type="select" label="Preprocessing methods">
                    <option value="Normalization" selected="true">Intensity Normalization</option>
                    <option value="Baseline_reduction">Baseline Reduction</option>
                    <option value="Smoothing">Peak smoothing</option>
                    <!--option value="mz_alignment">m/z alignment</option-->
                    <option value="mz_recalibration">m/z recalibration</option>
                    <option value="Peak_picking">Peak picking</option>
                    <option value="Peak_alignment">Peak alignment</option>
                    <option value="Peak_filtering">Peak filtering</option>
                    <option value="Peak_binning">Peak binning to reference peaks</option>
                    <option value="Mass_binning">m/z binning</option>
                    <option value="Transformation">Transformation</option>
                    <option value="ComBat_batch_correction">ComBat batch correction of centroided data</option>
                </param>
                <when value="Normalization">
                    <conditional name="methods_for_normalization">
                        <param name="normalization_method" type="select" label="Normalization method">
                            <option value="tic" selected="true">TIC</option>
                            <option value="rms">RMS</option>
                        </param>
                        <when value="tic"/>
                        <when value="rms"/>
                    </conditional>
                </when>
                <when value="Baseline_reduction">
                    <param name="baseline_method" type="select" label="Baseline reduction method">
                        <option value="locmin" selected="true" >locmin</option>
                        <option value="hull" >hull</option>
                        <option value="snip" >snip</option>
                        <option value="median" >median</option>
                    </param>
                </when>
                <when value="Smoothing">
                    <conditional name="methods_for_smoothing">
                        <param name="smoothing_method" type="select" label="Smoothing method" help="For more information, see the documentation of the matter package by Bemis et al.">
                            <option value="gaussian" selected="true">gaussian</option>
                            <option value="sgolay">Savitsky-Golay</option>
                            <option value="ma">moving average</option>
                            <!--option value="bilateral">bilateral</option-->
                            <option value="adaptive">adaptive bilateral</option>
                            <option value="diff">nonlinear diffusion smoothing</option>
                            <option value="guide">guided filtering</option>
                            <option value="pag">peak-aware guided filtering</option>
                        </param>
                        <when value="gaussian">
                            <param name="width_gaussian" type="integer" value="5"
                                   label="The width of the smoothing window for Gaussian smoothing. Must be positive and odd."/>
                            <param name="sd_gaussian" type="integer" value="2"
                                   label="The standard deviation of the smoothing window for Gaussian Smoothing. This controls the strength of smoothing for samples farther from the center of the smoothing window."/>
                        </when>
                        <when value="sgolay">
                            <param name="width_sgolay" type="integer" value="5"
                                   label="The width of the smoothing window for Savitzky-Golay smoothing. Must be positive and odd."/>
                            <param name="order_of_filters" type="integer" value="1"
                                   label="The polynomial order of the Savitzky-Golay filter coefficients. Must be smaller than width of the smoothing window."/>
                            <param name="deriv_sgolay" type="integer" value="0"
                                   label="The order of the derivative for the Savitzky-Golay filter coefficients"/>
                            <param name="delta_sgolay" type="integer" value="1"
                                   label="The sample spacing for the Savitzky-Golay filter. Only used if order of the derivative > 0"/>
                            <param name="replace_negatives" type="boolean" label="Replace negative intensities with 0." truevalue="true" falsevalue="false" checked="true" help="Savitzky golay smoothing can introduce negative intensity values it is recommended to replace them with zero"/>
                        </when>
                        <when value="ma">
                            <param name="width_ma" type="integer" value="5"
                                   label="The width of the smoothing window for Mowing Average smoothing. Must be positive and odd."/>
                        </when>
                        <!--when value="bilateral">
                            <param name="width_bilateral" type="integer" value="5"
                                   label="The width of the smoothing window for Bilateral smoothing. Must be positive and odd."/>
                            <param name="sd_bilateral" type="integer" value="2"
                                   label="The spatial parameter for the smoothing window (standard deviation). This controls the strength of smoothing for samples farther from the center of the smoothing window."/>
                            <param name="sdrange_bilateral" type="float" value="3"
                                   label="The range parameter for kernel-based filters. This controls the strength of the smoothing for samples with signal values very different from the center of the smoothing window."/-->
                        <when value="adaptive">
                            <param name="width_adaptive" type="integer" value="5"
                                   label="The width of the smoothing window for Mowing Average smoothing. Must be positive and odd."/>
                            <param name="spar_adaptive" type="integer" value="1"
                                   label="The strength of the smoothing when calculating the adaptive bilateral filtering parameters. The larger the number, the stronger the smoothing. Must be positive."/>
                        </when>
                        <when value="diff">
                            <param name="niter_diff" type="integer" value="5"
                                   label="The number of iterations for nonlinear diffusion. Must be positive."/>
                            <param name="kappa_diff" type="integer" value="50"
                                   label="The constant for the conduction coefficient for nonlinear diffusion. Must be positive."/>
                            <param name="rate_diff" type="float" value="0.25"
                                   label="The rate of diffusion. Must be between 0 and 0.25 for stability."/>
                            <!--param name="method_diff" type="integer" value="1"
                                   label="The diffusivity method, where 1 and 2 correspond to the two diffusivity functions proposed by Perona and Malik (1990), and 3 implements the peak-aware weighting."/-->
                        </when>
                        <when value="guide">
                            <param name="width_guide" type="integer" value="5"
                                   label="The width of the smoothing window for guided smoothing. Must be positive and odd."/>
                            <!--param name="guide_guide" type="integer" value="1"
                                   label="The guide signal for guided filtering. This is the signal used to determine the degree of filtering for different regions of the sample."/>
                            <param name="sdreg_guide" type="integer" value="1"
                                   label="The regularization parameter for guided filtering. Signal regions with variance much smaller than this value are smoothed, while signal regions with variance much larger than this value are preserved."/-->
                        </when>
                        <when value="pag">
                            <param name="width_pag" type="integer" value="5"
                                   label="The width of the smoothing window for guided smoothing. Must be positive and odd."/>
                            <!--param name="guide_pag" type="integer" value="1"
                                   label="The guide signal for peak-aware guided filtering. This is the signal used to determine the degree of filtering for different regions of the sample."/>
                            <param name="sdreg_pag" type="integer" value="1"
                                   label="The regularization parameter for  peak-aware guided filtering. Signal regions with variance much smaller than this value are smoothed, while signal regions with variance much larger than this value are preserved."/-->
                            <param name="ftol_pag" type="float" value="0.1"
                                   label="Specifies how large the signal value must be before it is considered a peak, expressed as a fraction of the maximum value in the signal."/>
                        </when>
                    </conditional>
                </when>

                <!--when value="mz_alignment">
                    <param name="alignment_tol" type="text" value="NA"
                           label="tolerance" help="The tolerance to be used when matching the peaks in the unaligned spectra to the reference spectrum. If this is NA, then automatically guess a tolerance from the data.">
                    </param>
                    <param name="alignment_units" type="select" display="radio" optional="false" label="The units to use for the tolerance.">
                            <option value="ppm" selected="true">ppm</option>
                            <option value="mz">m/z</option>
                    </param>
                    <conditional name="mzalign_ref_type">
                        <param name="align_reference_datatype" type="select" label="Choose reference">
                            <option value="align_noref" selected="true">use mean spectrum as reference</option>
                            <option value="align_table" >m/z values from tabular file as reference</option>
                        </param>
                        <when value="align_noref"/>
                        <when value="align_table">
                            <expand macro="reading_1_column_mz_tabular" label="Tabular file with m/z features to use for alignment. Only the m/z values from the tabular file will be kept."/>
                        </when>
                    </conditional>
                    <param name="quantile" type="float" value="0.2"
                        label="quantile" help="The top quantile of reference points (peaks detected via local maxima) to use from the reference spectrum."/>
                    <param name="span" type="float" value="0.75"
                        label="span" help="The smoothing parameter for the local polynomial regression used to determine the warping function."/>
                </when-->

	            <when value="mz_recalibration">
                    <conditional name="mz_recalibration_reference">
                        <param name="reference_type" type="select" label="Reference type" help="Select 'estimate reference m/z features' when no reference m/z features or calibrants are provided. Then, m/z features for recalibration are estimated from the data.">
                            <option value="estimate_reference" selected="true">estimate reference m/z features</option>
                            <option value="reference_mz">Tabular with reference m/z features</option>
                        </param>
                        <when value="estimate_reference"/>
                        <when value="reference_mz">
                              <expand macro="reading_1_column_mz_tabular" label="Tabular file with m/z features to use as reference for recalibration."/>
                        </when>
                    </conditional>
                    <param name="recalibration_method" type="select" label="Reference method" help="Select the reference method to recalibrate the spectra: local regression, dynamic time warping, or correlation optimized warping.">
                        <option value ="locmax" selected="true">local maxima</option>
                        <option value ="dtw" selected="true">dynamic time warping</option>
                        <option value ="cow" selected="true">correlation optimized warping</option>
                    </param>
                    <param name="recalibration_tolerance" type="integer" value="10" label="Tolerance" help="The tolerance for matching the peaks in the unaligned spectra to the reference. If this is NA, then automatically guess a tolerance from the data. "/>
                    <param name="recalibration_unit" type="select" display="radio" optional="false" label="Unit for tolerance">
                        <option value="ppm" selected="true">ppm</option>
                        <option value="mz">m/z</option>
                    </param>
                </when>

                <when value="Peak_picking">
                    <conditional name="methods_for_picking">
                        <param name="picking_method" type="select" label="Peak picking method (how to estimate noise):" help="For more details, please see the documentation of Cardinal and matter by Bemis et al.">
                            <option value="diff" selected="true">derivative of the signal (diff)</option>
                            <option value="mad">mean absolute deviation (mad)</option>
                            <option value="sd">standard deviation (sd) </option>
                            <option value="quantile">rolling quantile (of the difference between raw and smoothed signal)</option>
                            <option value="filter">dynamic filtering of the local peaks</option>
                            <option value="cwt">continuous wavelet transform (CWT)</option>
                        </param>
                            <when value="diff"/>
                            <when value="mad"/>
                            <when value="sd"/>
                            <when value="quantile"/>
                            <when value="filter"/>
                            <when value="cwt"/>
                    </conditional>
                    <param name="SNR_picking_method" type="float" value="6"
                        label="Signal to noise ratio"
                        help="The minimal signal to noise ratio for peaks to be considered as a valid peak."/>
                    <param name="picking_type" type="select" label="Should the peak height or area under the curve be used to summarize the peak?">
                            <option value="height" selected="true">height</option>
                            <option value="area">area</option>
                    </param>
                </when>
                <when value="Peak_alignment">
                    <param name="value_diffalignment" type="float" value="200"
                           label="tolerance" help="Peaks that differ less than this value will be aligned together"/>
                    <param name="units_diffalignment" type="select" display="radio" optional="false" label="units">
                            <option value="ppm" selected="true">ppm</option>
                            <option value="mz">m/z</option>
                    </param>
                    <conditional name="align_ref_type">
                        <param name="align_reference_datatype" type="select" label="Choose reference">
                            <option value="align_noref" selected="true">no reference</option>
                            <option value="align_table" >m/z values from tabular file as reference</option>
                        </param>
                        <when value="align_noref"/>
                        <when value="align_table">
                            <expand macro="reading_1_column_mz_tabular" label="Tabular file with m/z features to use for alignment. Only the m/z values from the tabular file will be kept."/>
                        </when>
                    </conditional>
                </when>
                <when value="Peak_filtering">
                    <param name="frequ_filtering" type="float" value="0.01" max="1" min="0" label="Minimum frequency" help="Peaks that occur in the dataset in lesser proportion than this will be dropped (0.01 --> filtering for 1% of spectra)"/>
                </when>
                <when value="Peak_binning">
                    <expand macro="reading_1_column_mz_tabular" label="A reference to which the peaks are binned." help="Tabular file with m/z features to extract from input file"/>
                    <param name="peakbin_tol" value="NA" type="text" label="The tolerance to be used when matching the m/z features in the dataset to the reference. If this is NA, then automatically guess a resolution from the data." >
                    </param>
                    <param name="peakbin_units" display="radio" type="select" label="The units to use for the tolerance.">
                        <option value="mz" >mz</option>
                        <option value="ppm" selected="true" >ppm</option>
                    </param>
                    <param name="peaks_type" type="select" display="radio"
                           label="Should the peak height or area under the curve be taken as the intensity value?">
                            <option value="height" selected="true">height</option>
                            <option value="area">area</option>
                    </param>
                </when>
                <when value="Mass_binning">
                    <param name="bin_width" type="float" value="100" label="The width of a bin in m/z or ppm" help="Width must be greater than range of m/z values divided by number of m/z features"/>
                    <param name="bin_units" type="select" display="radio"
                           label="Unit for the bin width">
                        <option value="ppm" selected="true" >ppm</option>
                        <option value="mz" >mz</option>
                    </param>
                    <param name="bin_tolerance" value="NA" type="text" label="The half-bin width. If this is NA, then automatically guess a resolution from the data." >
                    </param>
                    <param name="bin_method" type="select" display="radio"
                           label="How to calculate the intensity for ions of the same bin">
                            <option value="mean" selected="true">mean</option>
                            <option value="sum">sum</option>
                            <option value="max">max</option>
                            <option value="min">min</option>
                            <option value="linear">linear</option>
                            <option value="cubic">sucubicm</option>
                            <option value="gaussian">gaussian</option>
                            <option value="lanczos">lanczos</option>
                    </param>
                    <param name="replace_NA_bin" type="boolean" label="Replace NA with 0" truevalue="true" falsevalue="false" checked="true" help="Binning can introduce NAs, should they be replaced with 0"/>
                    <conditional name="mz_range">
                    	<param name="features_filtering" type="select" label="Select m/z options">
                            <option value="none" selected="true">none</option>
                            <option value="change_mz_range">change m/z range</option>
                            <option value="bin_to_reference">bin m/z to reference</option>
                        </param>
                        <when value="none"/>
                        <when value="change_mz_range">
                            <param name="min_mz" type="float" value="1" label="Minimum value for m/z"/>
                            <param name="max_mz" type="float" value="10000" label="Maximum value for m/z"/>
                        </when>
			            <when value="bin_to_reference">
                            <expand macro="reading_1_column_mz_tabular" label="Tabular file with m/z features as reference for binning. Only the m/z values from the tabular file will be kept."/>
                        </when>
                    </conditional>
                </when>
                <when value="Transformation">
                    <conditional name="transf_conditional">
                        <param name="trans_type" type="select" label="Intensity transformations" help="logarithm base 2 (log2) or squareroot (sqrt)">
                            <option value="log2" selected="true">log2</option>
                            <option value="sqrt">sqrt</option>
                        </param>
                            <when value="log2">
                                <param name="replace_NA_trans" type="boolean" label="Replace NA with 0" truevalue="true" falsevalue="false" checked="true" help="0 values are set to NA before log2 transformation, after transformation they can be set back to 0"/>
                            </when>
                            <when value="sqrt"/>
                    </conditional>
                </when>
                <when value="ComBat_batch_correction">
		     <param name="annotation_file" type="data" format="tabular" label="Annotation file that contains the pixel x and y coordinates, the batch identifier, and the condition annotation for each spectrum." help="Annotation tabular file that contains the batch identifier for each spectrum in one column."/>
                       <param name="x_column" type="data_column" data_ref="annotation_file" label="X coordinates" help="Column with x coordinates of pixels."/>
                       <param name="y_column" type="data_column" data_ref="annotation_file" label="Y coordinates" help="Column with y coordinates of pixels."/>
                       <param name="batch_column" type="data_column" data_ref="annotation_file" label="Batch column" help="The column that contains the batch identifier for each spectrum."/>
                       <param name="condition_column" type="data_column" data_ref="annotation_file" label="Condition column" help="The column that contains the condition annotation for each spectrum. Typically these are the groups you want to compare. If not applicable, the batch column can be selected again as this information is only used for the QC plot."/>
                       <param name="feature_header" type="boolean" label="Tabular file contains a header line" truevalue="true" falsevalue="false"/>
                </when>
            </conditional>
        </repeat>
    </inputs>
    <outputs>
        <data format="imzml" name="outfile_imzml" label="${tool.name} on ${on_string}: imzML"/>
        <data format="pdf" name="QC_overview" from_work_dir="Preprocessing.pdf" label = "${tool.name} on ${on_string}: QC"/>
    </outputs>
    <tests>
        <!-- Test 1: Peak Picking with Adaptive method -->
        <test>
            <expand macro="infile_imzml"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_picking"/>
                    <param name="SNR_picking_method" value="6"/>
                    <conditional name="methods_for_picking">
                        <param name="picking_method" value="cwt"/>
                    </conditional>
                </conditional>
            </repeat>
            <output name="QC_overview" file="preprocessing_results1.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results1.imzml.txt" compare="sim_size"/>
        </test>

        <!-- Test 2: Peak Picking with MAD method -->
        <test>
            <param name="infile" value="3_files_combined.RData" ftype="rdata"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_picking"/>
                    <param name="SNR_picking_method" value="3"/>
                    <conditional name="methods_for_picking">
                        <param name="picking_method" value="mad"/>
                    </conditional>
                </conditional>
            </repeat>
            <output name="QC_overview" file="preprocessing_results2.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results2.imzml.txt" compare="sim_size"/>
        </test>

        <!-- Test 3: Peak Picking with SD method -->
        <test>
            <expand macro="infile_analyze75"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_picking"/>
                    <param name="SNR_picking_method" value="2"/>
                    <conditional name="methods_for_picking">
                        <param name="picking_method" value="sd"/>
                    </conditional>
                </conditional>
            </repeat>
            <output name="QC_overview" file="preprocessing_results3.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results3.imzml.txt" compare="sim_size"/>
        </test>

        <!-- Test 4: Transformation - log2 -->
        <test>
            <expand macro="infile_analyze75"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Transformation"/>
                    <conditional name="transf_conditional">
                        <param name="trans_type" value="log2"/>
                        <param name="replace_NA_trans" value="true"/>
                    </conditional>
                </conditional>
            </repeat>
            <output name="QC_overview" file="preprocessing_results4.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results4.imzml.txt" compare="sim_size"/>
        </test>

        <!-- Test 5: ComBat batch correction -->
        <test>
            <expand macro="processed_infile_imzml"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="ComBat_batch_correction"/>
                    <param name="annotation_file" value="annotation_example.tabular" ftype="tabular"/>
                    <param name="feature_header" value="true"/>
                    <param name="x_column" value="2"/>
                    <param name="y_column" value="3"/>
                    <param name="batch_column" value="4"/>
                    <param name="condition_column" value="5"/>
                </conditional>
            </repeat>
            <output name="QC_overview" file="preprocessing_results5.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results5.imzml.txt" compare="sim_size"/>
        </test>
    </tests>
    <help>
        <![CDATA[

@CARDINAL_DESCRIPTION@

-----

This tool provides multiple Cardinal functions to preprocess mass spectrometry imaging data. 

@MSIDATA_INPUT_DESCRIPTION@
- Coordinates stored as decimals rather than integers will be rounded to obtain a regular pixel grid. This might lead to duplicated coordinates which will be automatically removed after the data is read by the tool.
@MZ_TABULAR_INPUT_DESCRIPTION@

**Options**

- Normalization: normalization of intensities to total ion current (TIC) or to root-mean-square (RMS)
- Baseline reduction: baseline reduction removes background intensity generated by chemical noise (common in MALDI datasets), either based on a baseline from local minima (locmin), convex hull estimation (hull), sensitive nonlinear interative peak (SNIP) clipping, or from medians (median)
- Smoothing: Smoothing of the peaks reduces noise and improves peak detection
- m/z alignment: removes small m/z shifts between spectra 
- Peak picking: relevant peaks are picked while noise-peaks are removed (needs peak alignment afterwards)
- Peak alignment: only possible after peak picking, m/z inaccuracies are removed by alignment of same peaks to a common m/z value; if no reference is given the peaks are aligned to the local maxima of the mean spectrum of the current dataset; external reference data can be used from another MSI data file or a tabular file with m/z values, but then only the m/z from the reference will be kept
- Peak filtering: removes peaks that occur only in a small proportion of pixels. If not sure which cut off to choose run quality control tool first and decide according to the number of peaks per m/z plot
- Peak binning: extracts peaks intensities, either peak height or area under curve (from a profile dataset) for a list of m/z (reference) values
- m/z binning: generates new m/z bins
- Transformation: log2 or squareroot transformation of all intensities; when using log2 transformation zero intensities will become NA, this can lead to compatibility problems. 
- ComBat batch correction: corrects the intensity values of picked m/z features according to batches given in an annotation table. For now, it can only be applied to m/z features after peak picking (=centroided data). The annotation table needs to contain the x and y coordinates for each pixel and a batch identifier (e.g. TMA_1, TMA_2, TMA_3). Additionally, a condition column can be provided, which is only used for the PCA plots in the pdf file. Example of annotation file for ComBat batch correction:
 
 ::
 
   	   x_coord     y_coord      batch_identifier	condition
  	       10          29          TMA_1                  A
  	       22          14          TMA_1                  B
  	       22          27          TMA_2                  A
  	       23           7          TMA_2                  B
   	       29          45          TMA_3                  A
   	       33          41          TMA_3                  B
   	    ...
   	    ...

                    

**Output**

- MSI data as continuous or processed imzML file depending on input imzML format and preprocessing
- pdf with key values and four random mass spectra after each processing step

        ]]>
    </help>
    <expand macro="citations"/>
</tool>


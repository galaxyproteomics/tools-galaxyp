<tool id="cardinal_preprocessing" name="MSI preprocessing" version="@VERSION@.3">
    <description>
        mass spectrometry imaging preprocessing
    </description>
    <macros>
        <import>macros.xml</import>
    </macros>
    <expand macro="requirements">
        <requirement type="package" version="2.3">r-gridextra</requirement>
        <requirement type="package" version="3.0">r-ggplot2</requirement>
        <requirement type="package" version="0.20_35">r-lattice</requirement>
    </expand>
    <command detect_errors="exit_code">
    <![CDATA[

        @INPUT_LINKING@
        cat '${cardinal_preprocessing}' &&
        Rscript '${cardinal_preprocessing}' &&

        #if str($imzml_output) == "imzml_format":
        mkdir $outfile_imzml.files_path &&
            mv ./out.imzML "${os.path.join($outfile_imzml.files_path, 'imzml')}" | true &&
            mv ./out.ibd "${os.path.join($outfile_imzml.files_path, 'ibd')}" | true &&
        #end if
        echo "imzML file:" > $outfile_imzml &&
        ls -l "$outfile_imzml.files_path" >> $outfile_imzml

    ]]>
    </command>
    <configfiles>
        <configfile name="cardinal_preprocessing"><![CDATA[

################################# load libraries and read file #################

library(Cardinal)
library(gridExtra)
library(lattice)
library(ggplot2)

@READING_MSIDATA@

@READING_MSIDATA_INRAM@  ###change out

## remove duplicated coordinates, otherwise peak picking and log2 transformation will fail
msidata <- msidata[,!duplicated(coord(msidata)[,1:2])]


if (ncol(msidata)>0 & nrow(msidata) >0){                                         

    ## start QC report

    pdf("Preprocessing.pdf", fonts = "Times", pointsize = 12)
    plot(0,type='n',axes=FALSE,ann=FALSE)
    title(main=paste("Quality control during preprocessing \n", "Filename:", "$infile.display_name"))

    ######################### preparations for QC report #################

    maxfeatures =nrow(msidata)
    pixelcount = ncol(msidata)
    minmz = round(min(mz(msidata)), digits=2)
    maxmz = round(max(mz(msidata)), digits=2)
    QC_numbers= data.frame(inputdata = c(minmz, maxmz,maxfeatures, pixelcount))
    vectorofactions = "inputdata"
    ## Choose random spectra for QC plots
    random_spectra = sample(pixels(msidata), 4, replace=FALSE)
    par(mfrow = c(2, 2), oma=c(0,0,2,0))
    for (random_sample in 1:length(random_spectra)){
        plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
    title("Input spectra", outer=TRUE, line=0)


    ############################### Preprocessing steps ###########################
    ###############################################################################

    #for $method in $methods:

    ############################### Normalization ###########################

        #if str( $method.methods_conditional.preprocessing_method ) == 'Normalization':
            print('Normalization')
            ##normalization

            msidata = normalize(msidata, method="tic")

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            normalized = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, normalized)
            vectorofactions = append(vectorofactions, "normalized")
            par(mfrow = c(2, 2), oma=c(0,0,2,0))
            for (random_sample in 1:length(random_spectra)){
                plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
            title("Spectra after normalization", outer=TRUE, line=0)

    ############################### Baseline reduction ###########################

        #elif str( $method.methods_conditional.preprocessing_method ) == 'Baseline_reduction':
            print('Baseline_reduction')
            ##baseline reduction

            msidata = reduceBaseline(msidata, method="median", blocks=$method.methods_conditional.blocks_baseline, spar=$method.methods_conditional.spar_baseline)

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            baseline = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, baseline)
            vectorofactions = append(vectorofactions, "baseline red.")
            for (random_sample in 1:length(random_spectra)){
                plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
            title("Spectra after baseline reduction", outer=TRUE, line=0)

    ############################### Smoothing ###########################

        #elif str( $method.methods_conditional.preprocessing_method ) == 'Smoothing':
            print('Smoothing')
            ## Smoothing

            #if str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'gaussian':
                print('gaussian smoothing')

                msidata = smoothSignal(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", window=$method.methods_conditional.window_smoothing, sd = $method.methods_conditional.methods_for_smoothing.sd_gaussian)

            #elif str( $method.methods_conditional.methods_for_smoothing.smoothing_method) == 'sgolay':
                print('sgolay smoothing')

                msidata = smoothSignal(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", window=$method.methods_conditional.window_smoothing, order = $method.methods_conditional.methods_for_smoothing.order_of_filters)

                ## if selected replace negative intensities with zero
                #if $method.methods_conditional.methods_for_smoothing.replace_negatives:
                    spectra(msidata)[spectra(msidata)<0] = 0
                #end if

            #elif str($method.methods_conditional.methods_for_smoothing.smoothing_method) == 'ma':
                print('moving average smoothing')

                msidata = smoothSignal(msidata, method="$method.methods_conditional.methods_for_smoothing.smoothing_method", window=$method.methods_conditional.window_smoothing, coef = $method.methods_conditional.methods_for_smoothing.coefficients_ma_filter)

            #end if

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            smoothed = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, smoothed)
            vectorofactions = append(vectorofactions, "smoothed")
            for (random_sample in 1:length(random_spectra)){
                plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
            title("Spectra after smoothing", outer=TRUE, line=0)

    ############################### Peak picking ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Peak_picking':
            print('Peak_picking')
            ## Peakpicking

            #if str( $method.methods_conditional.methods_for_picking.picking_method) == 'adaptive':
                print('adaptive peakpicking')

                msidata = peakPick(msidata, window = $method.methods_conditional.window_picking, blocks = $method.methods_conditional.blocks_picking, method='$method.methods_conditional.methods_for_picking.picking_method', SNR=$method.methods_conditional.SNR_picking_method, spar=$method.methods_conditional.methods_for_picking.spar_picking)

            #elif str( $method.methods_conditional.methods_for_picking.picking_method) == 'limpic':
                print('limpic peakpicking')

                msidata = peakPick(msidata, window = $method.methods_conditional.window_picking, blocks = $method.methods_conditional.blocks_picking, method='$method.methods_conditional.methods_for_picking.picking_method', SNR=$method.methods_conditional.SNR_picking_method, thresh=$method.methods_conditional.methods_for_picking.tresh_picking)

            #elif str( $method.methods_conditional.methods_for_picking.picking_method) == 'simple':
                print('simple peakpicking')

                msidata = peakPick(msidata, window = $method.methods_conditional.window_picking, blocks = $method.methods_conditional.blocks_picking, method='$method.methods_conditional.methods_for_picking.picking_method', SNR=$method.methods_conditional.SNR_picking_method)

            #end if

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            picked = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, picked)
            vectorofactions = append(vectorofactions, "picked")
            for (random_sample in 1:length(random_spectra)){
                plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
            title("Spectra after peak picking", outer=TRUE, line=0)

    ############################### Peak alignment ###########################

        #elif str( $method.methods_conditional.preprocessing_method ) == 'Peak_alignment':
            print('Peak_alignment')
            ## Peakalignment

            #if str( $method.methods_conditional.align_ref_type.align_reference_datatype) == 'align_noref':

                align_peak_reference = msidata

            #elif str( $method.methods_conditional.align_ref_type.align_reference_datatype) == 'align_table':

                align_reference_table = read.delim("$method.methods_conditional.align_ref_type.mz_tabular", header = $method.methods_conditional.align_ref_type.feature_header, stringsAsFactors = FALSE)
                align_reference_column = align_reference_table[,$method.methods_conditional.align_ref_type.feature_column]
                align_peak_reference = align_reference_column[align_reference_column>=min(mz(msidata)) & align_reference_column<=max(mz(msidata))]
                if (length(align_peak_reference) == 0)
                    {align_peak_reference = 0}
           
            #elif str( $method.methods_conditional.align_ref_type.align_reference_datatype) == 'align_msidata_ref':

                    align_peak_reference = loadRData('$method.methods_conditional.align_ref_type.align_peaks_msidata')

            #end if

            #if str( $method.methods_conditional.methods_for_alignment.alignment_method) == 'diff':
                print('diff peakalignment')

                msidata = peakAlign(msidata, method='$method.methods_conditional.methods_for_alignment.alignment_method',diff.max =$method.methods_conditional.methods_for_alignment.value_diffalignment, units = "$method.methods_conditional.methods_for_alignment.units_diffalignment", ref=align_peak_reference)

           #elif str( $method.methods_conditional.methods_for_alignment.alignment_method) == 'DP':
                print('DPpeakalignment')

            msidata = peakAlign(msidata, method='$method.methods_conditional.methods_for_alignment.alignment_method',gap = $method.methods_conditional.methods_for_alignment.gap_DPalignment, ref=align_peak_reference)

           #end if

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            aligned = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, aligned)
            vectorofactions = append(vectorofactions, "aligned")
            for (random_sample in 1:length(random_spectra)){
                plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
            title("Spectra after alignment", outer=TRUE, line=0)

    ############################### Peak filtering ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Peak_filtering':
            print('Peak_filtering')

            msidata = peakFilter(msidata, method='freq', freq.min = $method.methods_conditional.frequ_filtering)

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            filtered = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, filtered)
            vectorofactions = append(vectorofactions, "filtered")
            for (random_sample in 1:length(random_spectra)){
                plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
            title("Spectra after filtering", outer=TRUE, line=0)

    ############################### Data reduction ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Data_reduction':
            print('Data_reduction')

            #if str( $method.methods_conditional.methods_for_reduction.reduction_method) == 'bin':
                print('bin reduction')

                msidata = reduceDimension(msidata, method="bin", width=$method.methods_conditional.methods_for_reduction.bin_width, units="$method.methods_conditional.methods_for_reduction.bin_units", fun=$method.methods_conditional.methods_for_reduction.bin_fun)

                ## optional: replace NA with 0
                #if $method.methods_conditional.methods_for_reduction.replace_NA_bin:
                    ## count and replace NAs
                    print(paste0("Number of NA that were set to zero after binning:",sum(is.na(spectra(msidata)))))
                    spectra(msidata)[is.na(spectra(msidata))] = 0 
                #end if

            #elif str( $method.methods_conditional.methods_for_reduction.reduction_method) == 'resample':
                print('resample reduction')

                msidata = reduceDimension(msidata, method="resample", step=$method.methods_conditional.methods_for_reduction.resample_step)

            #elif str( $method.methods_conditional.methods_for_reduction.reduction_method) == 'peaks':
                print('peaks reduction')

                #if str( $method.methods_conditional.methods_for_reduction.ref_type.reference_datatype) == 'table':

                    reference_table = read.delim("$method.methods_conditional.methods_for_reduction.ref_type.mz_tabular", header = $method.methods_conditional.methods_for_reduction.ref_type.feature_header, stringsAsFactors = FALSE)
                    reference_column = reference_table[,$method.methods_conditional.methods_for_reduction.ref_type.feature_column]
                    peak_reference = reference_column[reference_column>min(mz(msidata)) & reference_column<max(mz(msidata))]

                #elif str( $method.methods_conditional.methods_for_reduction.ref_type.reference_datatype) == 'msidata_ref':

                        peak_reference = loadRData('$method.methods_conditional.methods_for_reduction.ref_type.peaks_msidata')

                #end if

                msidata = reduceDimension(msidata, method="peaks", ref=peak_reference, type="$method.methods_conditional.methods_for_reduction.peaks_type")
            #end if
            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            reduced = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, reduced)
            vectorofactions = append(vectorofactions, "reduced")
            for (random_sample in 1:length(random_spectra)){
                plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
            title("Spectra after data reduction", outer=TRUE, line=0)

        ############################### Transformation ###########################

        #elif str( $method.methods_conditional.preprocessing_method) == 'Transformation':
            print('Transformation')

            ## convert data into R matrix what brings it automatically into memory and can take some take but next steps need R matrix
            ##iData(msidata) <- iData(msidata)[]

            #if str( $method.methods_conditional.transf_conditional.trans_type) == 'log2':
                print('log2 transformation')

                ## replace 0 with NA to prevent Inf
                spectra_df = spectra(msidata)[] ## convert into R matrix
                spectra_df[spectra_df ==0] = NA
                print(paste0("Number of 0 which were converted into NA:",sum(is.na(spectra_df))))
                spectra(msidata) = spectra_df
                ## log transformation
                spectra(msidata) = log2(spectra(msidata))
                ## optional: replace NA with 0
                #if $method.methods_conditional.transf_conditional.replace_NA_trans:
                    spectra(msidata)[is.na(spectra(msidata))] = 0
                #end if

            #elif str( $method.methods_conditional.transf_conditional.trans_type) == 'sqrt':
                print('squareroot transformation')

                spectra(msidata) = sqrt(spectra(msidata)[])

           #end if

            ############################### QC ###########################

            maxfeatures =nrow(msidata)
            pixelcount = ncol(msidata)
            minmz = round(min(mz(msidata)), digits=2)
            maxmz = round(max(mz(msidata)), digits=2)
            transformed = c(minmz, maxmz,maxfeatures, pixelcount)
            QC_numbers= cbind(QC_numbers, transformed)
            vectorofactions = append(vectorofactions, "transformed")
            for (random_sample in 1:length(random_spectra)){
                plot(msidata, pixel=random_spectra[random_sample], main=paste0("spectrum ", names(random_spectra)[random_sample]))}
            title("Spectra after transformation", outer=TRUE, line=0)

            #end if
    #end for

    ############# Outputs: RData, imzml and QC report #############
    ################################################################################

    ## save msidata as imzML file, will only work if there is at least 1 m/z left

    #if str($imzml_output) == "imzml_format":
        if (nrow(msidata) > 0){
            ## make sure that coordinates are integers
            coord(msidata)\$y = as.integer(coord(msidata)\$y)
            coord(msidata)\$x = as.integer(coord(msidata)\$x)
            writeImzML(msidata, "out")}
    #elif str($imzml_output) == "rdata_format":
        ## save as (.RData)
        iData(msidata) = iData(msidata)[]
        save(msidata, file="$outfile_rdata")
    #end if

    plot(0,type='n',axes=FALSE,ann=FALSE)
    rownames(QC_numbers) = c("min m/z", "max mz", "# features", "# spectra")
    grid.table(t(QC_numbers))

    dev.off()

}else{
    print("inputfile has no intensities > 0")
}

    ]]></configfile>
    </configfiles>
    <inputs>
        <expand macro="reading_msidata"/>
        <repeat name="methods" title="Preprocessing" min="1" max="50">
            <conditional name="methods_conditional">
                <param name="preprocessing_method" type="select" label="Preprocessing methods">
                    <option value="Normalization" selected="True">Intensity Normalization (TIC)</option>
                    <option value="Baseline_reduction">Baseline Reduction</option>
                    <option value="Smoothing">Peak smoothing</option>
                    <option value="Peak_picking">Peak picking</option>
                    <option value="Peak_alignment">Peak alignment</option>
                    <option value="Peak_filtering">Peak filtering</option>
                    <option value="Data_reduction">Data reduction</option>
                    <option value="Transformation">Transformation</option>
                </param>
                <when value="Normalization"/>
                <when value="Baseline_reduction">
                    <param name="blocks_baseline" type="integer" value="500"
                        label="Blocks"/>
                    <param name="spar_baseline" type="float" value="1.0" label="Spar value" 
                           help = "Smoothing parameter for the spline smoothing 
                                  applied to the spectrum in order to decide the cutoffs 
                              for throwing away false noise spikes that might occur inside peaks"/>
                </when>
                <when value="Smoothing">
                    <conditional name="methods_for_smoothing">
                        <param name="smoothing_method" type="select" label="Smoothing method">
                            <option value="gaussian" selected="True">gaussian</option>
                            <option value="sgolay">Savitsky-Golay</option>
                            <option value="ma">moving average</option>
                        </param>
                        <when value="gaussian">
                            <param name="sd_gaussian" type="float" value="2"
                                   label="The standard deviation for the Gaussian kernel. Default = window/4"/>
                        </when>
                        <when value="sgolay">
                            <param name="order_of_filters" type="integer" value="3"
                                   label="The order of the smoothing filter, must be smaller than window size"/>
                            <param name="replace_negatives" type="boolean" label="Replace negative intensities with 0" truevalue="TRUE" falsevalue="FALSE" checked="True" help="Savitzky golay smoothing can introduce negative intensity values it is recommended to replace them with zero"/>
                        </when>
                        <when value="ma">
                            <param name="coefficients_ma_filter" type="float" value="1"
                                   label="The coefficients for the moving average filter"/>
                        </when>
                    </conditional>
                    <param name="window_smoothing" type="float" value="8"
                                label="Window size"/>
                </when>
                <when value="Peak_picking">
                    <param name="SNR_picking_method" type="integer" value="6"
                        label="Signal to noise ratio"
                        help="The minimal signal to noise ratio for peaks to be considered as a valid peak."/>
                    <param name="blocks_picking" type="integer" value="100" label = "Number of blocks"
                        help="Number of blocks in which to divide mass spectrum to calculate noise"/>
                    <param name="window_picking" type="float" value="5" label= "Window size" help="Window width for seeking local maxima"/>
                    <conditional name="methods_for_picking">
                        <param name="picking_method" type="select" label="Peak picking method" help="only simple works for processed imzML files">
                            <option value="adaptive" selected="True">adaptive</option>
                            <option value="limpic">limpic</option>
                            <option value="simple">simple</option>
                        </param>
                        <when value="adaptive">
                            <param name="spar_picking" type="float" value="1.0"
                                label="Spar value" 
                                help = "Smoothing parameter for the spline smoothing 
                                  applied to the spectrum in order to decide the cutoffs 
                                  for throwing away false noise spikes that might occur inside peaks"/>
                        </when>
                        <when value="limpic">
                            <param name="tresh_picking" type="float" value="0.75"
                                label="thresh value" help="The thresholding quantile to use when comparing slopes in order to throw away peaks that are too flat"/>
                        </when> 
                        <when value="simple"/>
                    </conditional>
                </when>
                <when value="Peak_alignment">
                    <conditional name="methods_for_alignment">
                        <param name="alignment_method" type="select" label="Alignment method">
                            <option value="diff" selected="True">diff</option>
                            <option value="DP">DP</option>
                        </param>
                        <when value="diff">
                            <param name="value_diffalignment" type="float" value="200"
                                   label="diff.max" help="Peaks that differ less than this value will be aligned together"/>
                            <param name="units_diffalignment" type="select" display="radio" optional="False" label="units">
                                    <option value="ppm" selected="True">ppm</option>
                                    <option value="mz">m/z</option>
                            </param>
                        </when>
                        <when value="DP">
                            <param name="gap_DPalignment" type="float" value="0"
                                   label="Gap" help="The gap penalty for the dynamic programming sequence alignment"/>
                        </when>
                    </conditional>
                    <conditional name="align_ref_type">
                        <param name="align_reference_datatype" type="select" label="Choose reference">
                            <option value="align_noref" selected="True">no reference</option>
                            <option value="align_table" >tabular file as reference</option>
                            <option value="align_msidata_ref">msidata file as reference</option>
                        </param>
                        <when value="align_noref"/>
                        <when value="align_table">
                            <expand macro="reading_1_column_mz_tabular" label="Tabular file with m/z features to use for alignment. Only the m/z values from the tabular file will be kept."/>
                        </when>
                        <when value="align_msidata_ref">
                            <param name="align_peaks_msidata" type="data" format="rdata," label="Picked and aligned Cardinal MSImageSet saved as RData"/>
                        </when>
                    </conditional>
                </when>
                <when value="Peak_filtering">
                    <param name="frequ_filtering" type="integer" value="1000"
                        label="Freq.min" help="Peaks that occur in the dataset fewer times than this will be removed. Number should be between 1 (no filtering) and number of spectra (pixel)"/>
                </when>
                <when value="Data_reduction">
                    <conditional name="methods_for_reduction">
                        <param name="reduction_method" type="select" label="Reduction method">
                            <option value="bin" selected="True">bin</option>
                            <option value="resample">resample</option>
                            <option value="peaks">peaks</option>
                        </param>
                        <when value="bin">
                            <param name="bin_width" type="float" value="1"
                                   label="The width of a bin in m/z or ppm" help="Width must be greater than range of m/z values divided by number of m/z features"/>
                            <param name="bin_units" type="select" display="radio"
                                   label="Unit for bin">
                                    <option value="mz" selected="True">mz</option>
                                    <option value="ppm">ppm</option>
                            </param>
                            <param name="bin_fun" type="select" display="radio"
                                   label="Calculate sum or mean intensity for ions of the same bin">
                                    <option value="mean" selected="True">mean</option>
                                    <option value="sum">sum</option>
                            </param>
                            <param name="replace_NA_bin" type="boolean" label="Replace NA with 0" truevalue="TRUE" falsevalue="FALSE" checked="True" help="Binning can introduce NAs, should they be replaced with 0"/>
                        </when>
                        <when value="resample">
                            <param name="resample_step" type="float" value="1"
                                   label="The step size in m/z" help="Step size must be greater than range of m/z values divided by number of m/z features"/>
                        </when>
                        <when value="peaks">
                            <param name="peaks_type" type="select" display="radio"
                                   label="Should the peak height or area under the curve be taken as the intensity value?">
                                    <option value="height" selected="True">height</option>
                                    <option value="area">area</option>
                            </param>                            
                            <conditional name="ref_type">
                                <param name="reference_datatype" type="select" label="Choose reference datatype">
                                    <option value="table" selected="True">tabular file</option>
                                    <option value="msidata_ref">msidata file</option>
                                </param>
                                <when value="table">
                                    <expand macro="reading_1_column_mz_tabular" label="Tabular file with m/z features to extract from input file"/>
                                </when>
                                <when value="msidata_ref">
                                    <param name="peaks_msidata" type="data" format="rdata," label="Picked and aligned Cardinal MSImageSet saved as RData"/>
                                </when>
                            </conditional>
                        </when>
                    </conditional>
                </when>
                <when value="Transformation">
                    <conditional name="transf_conditional">
                        <param name="trans_type" type="select" label="Intensity transformations" help="logarithm base 2 (log2) or squareroot (sqrt)">
                            <option value="log2" selected="True">log2</option>
                            <option value="sqrt">sqrt</option>
                        </param>
                            <when value="log2">
                                <param name="replace_NA_trans" type="boolean" label="Replace NA with 0" truevalue="TRUE" falsevalue="FALSE" checked="True" help="0 values are set to NA before log2 transformation, after transformation they can be set back to 0"/>
                            </when>
                            <when value="sqrt"/>
                    </conditional>
                </when>
            </conditional>
        </repeat>
        <param name="imzml_output" type="select" display = "radio" optional = "False"
               label="Output format" help= "Choose the output format">
                <option value="imzml_format" >imzML</option>
                <option value="rdata_format" selected="True" >RData</option>
        </param>
    </inputs>
    <outputs>
        <data format="imzml" name="outfile_imzml" label="${tool.name} on ${on_string}: imzML">
            <filter>imzml_output=='imzml_format'</filter>
        </data>
        <data format="rdata" name="outfile_rdata" label="${tool.name} on ${on_string}: RData">
            <filter>imzml_output == 'rdata_format'</filter>
        </data>
        <data format="pdf" name="QC_overview" from_work_dir="Preprocessing.pdf" label = "${tool.name} on ${on_string}: QC"/>
    </outputs>
    <tests>
        <test>
            <expand macro="infile_imzml"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Normalization"/>
                    <conditional name="methods_for_normalization">
                        <param name="normalization_method" value="median"/>
                    </conditional>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Smoothing"/>
                    <conditional name="methods_for_smoothing">
                        <param name="smoothing_method" value="gaussian"/>
                        <param name="sd_gaussian" value="4"/>
                    </conditional>
                        <param name="window_smoothing" value="9"/>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_picking"/>
                    <conditional name="methods_for_picking">
                        <param name="picking_method" value="adaptive"/>
                    </conditional>
                    <param name="blocks_picking" value="3"/>
                    <param name="window_picking" value="3"/>
                    <param name="SNR_picking_method" value="3"/>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_alignment"/>
                    <conditional name="methods_for_alignment">
                        <param name="alignment_method" value="diff"/>
                    </conditional>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_filtering"/>
                    <param name="frequ_filtering" value="2"/>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Transformation"/>
                        <conditional name="transf_conditional">
                            <param name="trans_type" value="sqrt"/>
                        </conditional>
                </conditional>
            </repeat>
            <param name="imzml_output" value="imzml_format"/>
            <output name="QC_overview" file="preprocessing_results1.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results1.imzml.txt" compare="sim_size">
                <extra_files type="file" file="preprocessing_results1.imzml" name="imzml" lines_diff="4"/>
                <extra_files type="file" file="preprocessing_results1.ibd" name="ibd" compare="sim_size"/>
            </output>
        </test>
        <test>
            <param name="infile" value="3_files_combined.RData" ftype="rdata"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_picking"/>
                    <param name="blocks_picking" value="3"/>
                    <param name="window_picking" value="5"/>
                    <param name="SNR_picking_method" value="2"/>
                    <conditional name="methods_for_picking">
                        <param name="picking_method" value="adaptive"/>
                    </conditional>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_alignment"/>
                    <conditional name="methods_for_alignment">
                        <param name="alignment_method" value="DP"/>
                    </conditional>
                </conditional>
            </repeat>
            <param name="imzml_output" value="imzml_format"/>
            <output name="QC_overview" file="preprocessing_results2.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results2.imzml.txt" compare="sim_size">
                <extra_files type="file" file="preprocessing_results2.imzml" name="imzml" lines_diff="4"/>
                <extra_files type="file" file="preprocessing_results2.ibd" name="ibd" compare="sim_size"/>
            </output>
        </test>
        <test>
            <expand macro="infile_analyze75"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Normalization"/>
                    <conditional name="methods_for_normalization">
                        <param name="normalization_method" value="median"/>
                    </conditional>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_picking"/>
                    <param name="blocks_picking" value="100"/>
                    <param name="window_picking" value="5"/>
                    <param name="SNR_picking_method" value="3"/>
                        <param name="picking_method" value="limpic"/>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Peak_alignment"/>
                    <conditional name="methods_for_alignment">
                        <param name="alignment_method" value="diff"/>
                    </conditional>
                </conditional>
            </repeat>
            <param name="imzml_output" value="imzml_format"/>
            <output name="QC_overview" file="preprocessing_results3.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results3.imzml.txt" compare="sim_size">
                <extra_files type="file" file="preprocessing_results3.imzml" name="imzml" lines_diff="4"/>
                <extra_files type="file" file="preprocessing_results3.ibd" name="ibd" compare="sim_size"/>
            </output>
        </test>
        <test>
            <expand macro="infile_analyze75"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Normalization"/>
                </conditional>
            </repeat>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Data_reduction"/>
                    <param name="bin_width" value="0.1"/>
                </conditional>
            </repeat>
            <param name="imzml_output" value="imzml_format"/>
            <output name="QC_overview" file="preprocessing_results4.pdf" compare="sim_size"/>
            <output name="outfile_imzml" ftype="imzml" file="preprocessing_results4.imzml.txt" compare="sim_size">
                <extra_files type="file" file="preprocessing_results4.imzml" name="imzml" lines_diff="4"/>
                <extra_files type="file" file="preprocessing_results4.ibd" name="ibd" compare="sim_size"/>
            </output>
        </test>
        <test>
            <expand macro="infile_imzml"/>
            <repeat name="methods">
                <conditional name="methods_conditional">
                    <param name="preprocessing_method" value="Data_reduction"/>
                        <conditional name="methods_for_reduction">
                            <param name="reduction_method" value="resample"/>
                            <param name="step_width" value="0.1"/>
                        </conditional>
                </conditional>
            </repeat>
            <param name="imzml_output" value="rdata_format"/>
            <output name="outfile_rdata" file="preprocessing_results5.RData" compare="sim_size"/>
            <output name="QC_overview" file="preprocessing_results5.pdf" compare="sim_size"/>
        </test>
    </tests>
    <help>
        <![CDATA[

@CARDINAL_DESCRIPTION@

-----

This tool provides multiple Cardinal functions to preprocess mass spectrometry imaging data. 

@MSIDATA_INPUT_DESCRIPTION@
- Coordinates stored as decimals rather than integers will be rounded to obtain a regular pixel grid. This might lead to duplicated coordinates which will be automatically removed after the data is read by the tool.
@MZ_TABULAR_INPUT_DESCRIPTION@

**Options**

- Normalization: Normalization of intensities to total ion current (TIC)
- Baseline reduction: Baseline  reduction removes background intensity generated by chemical noise (common in MALDI datasets)
- Smoothing: Smoothing of the peaks reduces noise and improves peak detection
- Peak picking: relevant peaks are picked while noise-peaks are removed (needs peak alignment afterwards)
- Peak alignment: only possible after peak picking, m/z inaccuracies are removed by alignment of same peaks to a common m/z value; if no reference is given the peaks are aligned to the local maxima of the mean spectrum of the current dataset; external reference data can be used from another MSI data file or a tabular file with m/z values, but then only the m/z from the reference will be kept
- Peak filtering: removes peaks that occur only in a small proportion of pixels. If not sure which cut off to choose run quality control tool first and decide according to the number of peaks per m/z plot
- Data reduction: binning, resampling or peak filtering to reduce data
- Transformation: log2 or squareroot transformation of all intensities; when using log2 transformation zero intensities will become NA, this can lead to compatibility problems. 

**Tips** 

- Peak alignment works only after peak picking
- Peak filtering works only on centroided data (peak picking and alignment or Data reduction peaks

**Output**

- MSI data as imzML file or .RData (can be read with the Cardinal package in R)
- pdf with key values and four random mass spectra after each processing step

        ]]>
    </help>
    <expand macro="citations"/>
</tool>


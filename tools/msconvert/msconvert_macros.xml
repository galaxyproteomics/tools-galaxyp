<macros>
  <token name="@VERSION@">3.0.20287</token>
  <token name="@FULL_VERSION@">@VERSION@-769529fa4</token>
  <token name="@PROFILE_VERSION@">23.2</token>
  <xml name="msconvertCommand">
    <command detect_errors="exit_code">
<![CDATA[
    #import re
    #set $ext = $input.ext

    ## sanitize display name for use as temp filename
    #set basename = $re.sub(r'[^\w ,.\-+]','_',$input.element_identifier)

    #if $ext == 'wiff':
      ln -s '${input.extra_files_path}/wiff' '${basename}.wiff' &&
      ln -s '${input.extra_files_path}/wiff_scan' '${basename}.wiff.scan' &&
      #set inputmask = "'"+$basename+"'"
    #elif $ext.endswith('tar'):
      ln -s '$input' '${basename}' &&
      tar xf '${basename}' &&
      #set basename = $os.path.splitext($basename)[0]
      #if $ext.startswith('waters'):
        #set inputmask = '*.raw'
      #elif $ext.startswith('agilent') or $ext.startswith('bruker'):
        #set inputmask = '*.d'
      #elif $ext.startswith('wiff'):
        #set inputmask = '*.wiff *.wiff2'
      #else
        #raise RuntimeError("Unrecognized type of tar (${ext})")
      #end if
    #else
      ln -s '$input' '${basename}' &&
      #set inputmask = "'"+$basename+"'"
    #end if

    #if $data_processing.precursor_refinement.use_mzrefinement == "true"
      #set input_ident_name = ".".join((os.path.splitext($basename)[0], $data_processing.precursor_refinement.input_ident.ext))
      #set output_refinement_name = os.path.splitext($basename)[0] + '.mzRefinement.tsv'
      ln -s '$data_processing.precursor_refinement.input_ident' '$input_ident_name' &&
    #end if

    CAN_SUDO=\$(sudo -n -l &> /dev/null || echo \$?) &&
    if [ "\$CAN_SUDO" -eq "" ]; then
      uid=`id -u` &&
      gid=`id -g` &&
      WINE="wine64_anyuser";
    else
      WINE="wine64" &&
      ## create a writable copy of wine prefix (since copying fails for some html
      ## stderr and exit code is swallowed)
      export WINEPREFIX=\$(mktemp -d) &&
      (cp -a /wineprefix64/* \$WINEPREFIX 2> /dev/null || true);
    fi
    &&
    \$WINE msconvert ${inputmask}

    --outdir outputs
    --${output_type}
    $general_options.combineIonMobilitySpectra
    $general_options.simAsSpectra
    $general_options.srmAsSpectra
    $general_options.acceptZeroLengthSpectra
    $general_options.ignoreUnknownInstrumentError

    #if $general_options.scan_summing.do_scan_summing == "true":
      --filter "scanSumming precursorTol=$general_options.scan_summing.precursorTol scanTimeTol=$general_options.scan_summing.scanTimeTol ionMobilityTol=$general_options.scan_summing.ionMobilityTol"
    #end if

    #if $general_options.multi_run_output.do_multi_run_output == "true":
      #if len($general_options.multi_run_output.run_index_set) > 0
        --runIndexSet "
        #for $index in $general_options.multi_run_output.run_index_set
          [${index.from},${index.to}]
        #end for
        "
      #end if
    #else
      --runIndexSet $general_options.multi_run_output.runIndexSet
    #end if

    ## Strip sourceFile location since it is meaningless on HPC systems and causes problems with functional tests
    --stripLocationFromSourceFiles

    ## DATA PROCESSING FILTERS (NOTE: FOR VENDOR METHOD TO WORK, PEAK PICKING MUST BE THE FIRST FILTER!)
      #if $data_processing.peak_picking.pick_peaks == "true"
        --filter "peakPicking $data_processing.peak_picking.pick_peaks_algorithm msLevel=$data_processing.peak_picking.pick_peaks_ms_levels"
      #end if

      #if $data_processing.precursor_refinement.use_mzrefinement == "true"
      --filter "mzRefiner $input_ident_name
        msLevels=$data_processing.precursor_refinement.precursor_refinement_ms_levels
        thresholdScore=$data_processing.precursor_refinement.thresholdScore
        thresholdValue=$data_processing.precursor_refinement.thresholdValue
        thresholdStep=$data_processing.precursor_refinement.thresholdStep
        maxSteps=$data_processing.precursor_refinement.thresholdMaxSteps assumeHighRes=1"
      #end if

      #if str($data_processing.charge_state_calculation.charge_state_calculation_method) == "predictor"
      --filter "chargeStatePredictor
        overrideExistingCharge=$data_processing.charge_state_calculation.predictor_overrideExistingCharge
        minMultipleCharge=$data_processing.charge_state_calculation.minMultipleCharge
        maxMultipleCharge=$data_processing.charge_state_calculation.maxMultipleCharge
        singleChargeFractionTIC=$data_processing.charge_state_calculation.singleChargeFractionTIC
        maxKnownCharge=$data_processing.charge_state_calculation.maxKnownCharge"
      #else if str($data_processing.charge_state_calculation.charge_state_calculation_method) == "turbocharger"
      --filter "turbocharger
        minCharge=$data_processing.charge_state_calculation.minCharge
        maxCharge=$data_processing.charge_state_calculation.maxCharge
        precursorsBefore=$data_processing.charge_state_calculation.precursorsBefore
        precursorsAfter=$data_processing.charge_state_calculation.precursorsAfter
        halfIsoWidth=$data_processing.charge_state_calculation.halfIsoWidth
        defaultMinCharge=$data_processing.charge_state_calculation.defaultMinCharge
        defaultMaxCharge=$data_processing.charge_state_calculation.defaultMaxCharge"
      #end if

      #for threshold_entry in $data_processing.thresholds
        --filter "threshold $threshold_entry.threshold_type $threshold_entry.value $threshold_entry.orientation"
      #end for

      #if $data_processing.filter_mz_windows.do_mzwindow_filter == "true"
        --filter "mzWindow [$data_processing.filter_mz_windows.mz_window_from,$data_processing.filter_mz_windows.mz_window_to]"
      #end if

      #if $data_processing.etd_filtering.do_etd_filtering == "true"
        --filter "ETDFilter $data_processing.etd_filtering.remove_precursor
          $data_processing.etd_filtering.remove_charge_reduced
          $data_processing.etd_filtering.remove_neutral_loss
          $data_processing.etd_filtering.blanket_removal
          $data_processing.etd_filtering.matching_tolerance$data_processing.etd_filtering.matching_tolerance_units"
      #end if

      #if $data_processing.ms2denoise.denoise == "true"
        --filter "MS2Denoise $data_processing.ms2denoise.num_peaks $data_processing.ms2denoise.window_width $data_processing.ms2denoise.relax"
      #end if

      #if str($data_processing.ms2deisotope) == "true"
        --filter "MS2Deisotope"
      #end if

      #if $data_processing.demultiplex.demultiplex_on == "true"
        --filter "demultiplex massError=$data_processing.demultiplex.massError$data_processing.demultiplex.massErrorUnits nnlsMaxIter=$data_processing.demultiplex.nnlsMaxIter nnlsEps=$data_processing.demultiplex.nnlsEps noWeighting=$data_processing.demultiplex.noWeighting demuxBlockExtra=$data_processing.demultiplex.demuxBlockExtra variableFill=$data_processing.demultiplex.variableFill noSumNormalize=$data_processing.demultiplex.noSumNormalize optimization=$data_processing.demultiplex.optimization interpolateRT=$data_processing.demultiplex.interpolateRT minWindowSize=$data_processing.demultiplex.minWindowSize"
      #end if

    ## SCAN INCLUSION/EXCLUSION FILTERS
      #if str($filtering.activation) != "false"
      --filter "activation $filtering.activation"
      #end if

      #if len($filtering.indices) > 0
        --filter "index
        #for $index in $filtering.indices
          [${index.from},${index.to}]
        #end for
        "
      #end if

      #if len($filtering.scan_numbers) > 0
        --filter "scanNumber
        #for $scan_number in $filtering.scan_numbers
          [${scan_number.from},${scan_number.to}]
        #end for
        "
      #end if

      #if $filtering.strip_it.value
         --filter "stripIT"
      #end if

      #if $filtering.filter_ms_levels.do_ms_level_filter == "true"
        --filter "msLevel [$filtering.filter_ms_levels.ms_level_from, $filtering.filter_ms_levels.ms_level_to]"
      #end if

      #if str($filtering.polarity) != "false"
        --filter "polarity $filtering.polarity"
      #end if

      #if str($filtering.analyzer) != "false"
        --filter "analyzer $filtering.analyzer"
      #end if

      ## OUTPUT ENCODING
      #set $mz_encoding = str($settings.mz_encoding)
      #set $intensity_encoding = str($settings.intensity_encoding)
      #if $mz_encoding == $intensity_encoding
        #if $mz_encoding == "64"
          --64
        #else
          --32
        #end if
      #else
        --mz${mz_encoding}
        --inten${intensity_encoding}
      #end if

      #set binary_compression = str($settings.binary_compression)
      #if $binary_compression == "zlib"
        --"zlib"
      #else if $binary_compression == "numpressLinearPic"
        --numpressLinear --numpressPic
      #else if $binary_compression == "numpressLinearSlof"
        --numpressLinear --numpressSlof
      #else if $binary_compression == "numpressLinear"
        --numpressLinear
      #else if $binary_compression == "numpressPic"
        --numpressPic
      #else if $binary_compression == "numpressSlof"
        --numpressSlof
      #end if

      #if $settings.gzip_compression == "true"
        --gzip
      #end if

      #if $general_options.multi_run_output.do_multi_run_output == 'false':
        --outfile '${os.path.splitext($basename)[0]}'
      #end if
      && 
      if [ "\$CAN_SUDO" -eq "0" ]; then
        sudo chown -R \$uid:\$gid './';
      fi
      #if $general_options.multi_run_output.do_multi_run_output == 'false':
        && mv 'outputs/${os.path.splitext($basename)[0]}.${output_type}' '${output}'
      #else
        ## make mzML and mzXML extensions lower case (the Galaxy data type is ) otherwise detetion of the file
        ## this won't be necessay from Galaxy 25.0 https://github.com/galaxyproject/galaxy/pull/19954
        #if $output_type == 'mzML' or $output_type == 'mzXML'
          && find outputs/ -name "*.$output_type" | xargs -I "FILE" sh -c 'mv FILE outputs/\$(basename FILE .$output_type).#echo str($output_type).lower()
          ## a newline is needed after `#echo ...` therefore the `;'` on the next line
;'
        #end if
      #end if

      #if $data_processing.precursor_refinement.use_mzrefinement == "true"
        && mv '$output_refinement_name' '$output_refinement';
      #end if
]]>
    </command>
  </xml>

  <xml name="msconvertInputParameters">
    <param name="license_agreement" type="boolean" label="Do you agree to the vendor licenses?" help="This tool uses proprietary vendor libraries; to run it you must agree to the vendor licenses. Read them at http://www.proteowizard.org/licenses.html">
        <validator type="expression" message="You must agree to the vendor licenses to run msconvert.">True == value</validator>
    </param>

    <param name="output_type" type="select" label="Output Type">
      <option value="mz5" selected="true">mz5</option>
      <option value="mzML">mzML</option>
      <option value="mzXML">mzXML</option>
      <option value="mgf">mgf</option>
      <option value="ms2">ms2</option>
    </param>

    <section name="data_processing" title="Data Processing Filters">
        <conditional name="peak_picking">
            <param type="select" name="pick_peaks" label="Apply peak picking?">
                <option value="true">Yes</option>
                <option value="false" selected="true">No</option>
            </param>
            <when value="false" />
            <when value="true">
                <param name="pick_peaks_ms_levels" type="select" label="Peak Peaking - Apply to MS Levels">
                    <option value="1">MS1 Only (1)</option>
                    <option value="2">MS2 Only (2)</option>
                    <option value="2-">MS2 and on (2-)</option>
                    <option value="1-" selected="true">All Levels (1-)</option>
                </param>
                <param type="select" name="pick_peaks_algorithm" label="Peak Picking - Algorithm" help="The vendor method only works on Agilent, Bruker, Sciex, Thermo data, and only on Windows (although some vendors work on Wine)">
                    <option value="vendor" selected="true">Prefer vendor algorithm, fallback to local-maximum</option>
                    <option value="cwt">CantWaiT - continuous wavelet transform</option>
                </param>
            </when>
      </conditional>

      <conditional name="precursor_refinement">
        <param type="select" name="use_mzrefinement" label="Apply m/z refinement with identification data?">
            <option value="true">Yes</option>
            <option value="false" selected="true">No</option>
        </param>
        <when value="false"></when>
        <when value="true">
          <param name="input_ident" type="data" format="pepxml,mzid" label="MZRefinery - Input identification data" />
          <param name="thresholdScore" type="text" value="mvh" label="MZRefinery - Threshold Score Name" help="E.g. 'mvh' for MyriMatch, 'xcorr' for Sequest, 'specevalue' for MS-GF+">
            <sanitizer>
              <valid initial="string.letters" />
            </sanitizer>
          </param>
          <param name="thresholdValue" type="text" value="50-" label="MZRefinery - Threshold Score Value" help="MZRefinery uses peptide-spectrum-matches with scores from this range to build its model. '100-' means score equal to or greater than 100. '-1e-10' means less than or equal to 1e-10.">
            <sanitizer>
              <valid initial="string.letters,string.digits">
                <add value="-" />
              </valid>
            </sanitizer>
          </param>
          <param name="thresholdStep" type="float" value="0" label="MZRefinery - Threshold Score Step" help="If there are not enough quality hits at the given score threshold value, the threshold can be increased by this step (until maxSteps is reached)." />
          <param name="thresholdMaxSteps" type="integer" value="0" label="MZRefinery - At most, how many steps to widen the threshold?" />
          <param name="precursor_refinement_ms_levels" type="select" label="MZRefinery - Apply to MS Levels">
            <option value="1">MS1 Only (1)</option>
            <option value="2">MS2 Only (2)</option>
            <option value="2-">MS2 and on (2-)</option>
            <option value="1-" selected="true">All Levels (1-)</option>
          </param>
        </when>
      </conditional>

      <conditional name="charge_state_calculation">
        <param name="charge_state_calculation_method" type="select" label="(Re-)calculate charge states?">
          <option value="false">no</option>
          <option value="predictor">Based on how much intensity is above vs. below the precursor m/z in the MS/MS scan</option>
          <option value="turbocharger">Based on isotopic distribution of the precursor in nearby survey scans</option>
        </param>
        <when value="false" />
        <when value="predictor">
          <param name="predictor_overrideExistingCharge" type="boolean" label="Always override existing charge?" value="false" />
          <param name="minMultipleCharge" type="integer" label="Minimum multiple charge state" value="2" />
          <param name="maxMultipleCharge" type="integer" label="Maximum multiple charge state" value="3" />
          <param name="singleChargeFractionTIC" type="float" label="Fraction of intensity below the precursor to be considered singly charged" max="1" min="0" value="0.9" />
          <param name="maxKnownCharge" type="integer" label="Maximum charge allowed for &quot;known&quot; charges" help="This is applied even when not overriding existing charges (i.e. it overrides only obviously bogus charge states)" value="0" />
        </when>
        <when value="turbocharger">
          <param name="minCharge" type="integer" label="Minimum possible charge state" value="1" min="1" help="Charge states lower than this will not be considered." />
          <param name="maxCharge" type="integer" label="Maximum possible charge state" value="8" min="2" help="Charge states greater than this will not be considered." />
          <param name="precursorsBefore" type="integer" label="Number of preceding survey scans to check for precursor isotopes" value="2" min="1" />
          <param name="precursorsAfter" type="integer" label="Number of succeeding survey scans to check for precursor isotopes" value="0" min="0" />
          <param name="halfIsoWidth" type="float" label="Half-width of isolation window" min="0.0001" value="1.25" />
          <param name="defaultMinCharge" type="integer" label="Minimum possible charge state to apply if no isotope is found" value="0" />
          <param name="defaultMaxCharge" type="integer" label="Maximum possible charge state to apply if no isotope is found" value="0" />
        </when>
      </conditional>

      <repeat name="thresholds" title="Filter by Threshold">
        <param type="select" label="Specify threshold on" name="threshold_type" help="">
          <option value="count">Peak count</option>
          <option value="count-after-ties">Peak count (after ties)</option>
          <option value="absolute">Peak absolute intensity</option>
          <option value="bpi-relative">Fraction of base peak intensity</option>
          <option value="tic-relative">Fraction of total ion current</option>
          <option value="tic-fraction">Aggregate fraction of total ion current</option>
        </param>
        <param type="float" name="value" label="Threshold" value="1" help="For count methods, this is the number of peaks to keep. For the absolute method, this is the raw intensity above/below which peak will be accepted. For the &quot;Aggregated fraction&quot; method, peaks are accepted until this fraction of the TIC is accounted for." />
        <param type="select" label="Keep" name="orientation">
          <option value="most-intense">Most intense peaks</option>
          <option value="least-intense">Least intense peaks</option>
        </param>
      </repeat>

      <conditional name="filter_mz_windows">
        <param name="do_mzwindow_filter" type="select" label="Filter m/z Window" help="">
            <option value="true">Yes</option>
            <option value="false" selected="true">No</option>
        </param>
        <when value="false" />
        <when value="true">
          <param name="mz_window_from" type="float" label="Filter m/z From" value="0.0" optional="false" />
          <param name="mz_window_to" type="float" label="Filter m/z To" value="0.0" optional="true" />
        </when>
      </conditional>

      <conditional name="etd_filtering">
        <param type="select" name="do_etd_filtering" label="Filter out ETD precursor peaks?">
            <option value="true">Yes</option>
            <option value="false" selected="true">No</option>
        </param>
        <when value="false" />
        <when value="true">
          <param name="remove_precursor" type="select" label="ETD Remove Unreacted Precursor">
            <option value="true" selected="true">yes</option>
            <option value="false">no</option>
          </param>
          <param name="remove_charge_reduced" type="select" label="ETD Remove Charge Reduced Precursors">
            <option value="true" selected="true">yes</option>
            <option value="false">no</option>
          </param>
          <param name="remove_neutral_loss" type="select" label="ETD Remove Neutral Losses" help="Remove neutral loss species from nominal and charge reduced precursors">
            <option value="true" selected="true">yes</option>
            <option value="false">no</option>
          </param>
          <param name="blanket_removal" type="select" label="ETD Blanket Removal of Neutral Losses" help="Remove neutral losses in a charge-scaled 60 Da swath (rather than only around known loss species)">
            <option value="true" selected="true">yes</option>
            <option value="false">no</option>
          </param>
          <param name="matching_tolerance" type="float" label="ETD Matching Tolerance" value="3.1" />
          <param name="matching_tolerance_units" type="select" label="Units for ETD Matching Tolerance">
            <option value="MZ" selected="true">mz</option>
            <option value="PPM">ppm</option>
          </param>
        </when>
      </conditional>

      <conditional name="ms2denoise">
        <param name="denoise" type="select" label="De-noise MS2 with moving window filter">
            <option value="true">Yes</option>
            <option value="false" selected="true">No</option>
        </param>
        <when value="true">
          <param name="num_peaks" label="De-noise: Number of peaks in window" value="6" type="integer" />
          <param name="window_width" type="float" label="De-noise: Window width (Daltons)" value="30" />
          <param name="relax" label="De-noise: Multicharge fragment relaxation" checked="true" type="boolean" truevalue="true" falsevalue="false" />
        </when>
        <when value="false" />
      </conditional>

      <param name="ms2deisotope" type="boolean" label="Deisotope MS2 using Markey method" help="" truevalue="true" falsevalue="false" />

      <conditional name="demultiplex">
        <param name="demultiplex_on" type="select" label="Demultiplex overlapping or MSX spectra" help="Separates overlapping or MSX multiplexed spectra into several demultiplexed spectra by inferring from adjacent multiplexed spectra. Optionally handles variable fill times (for Thermo)">
            <option value="true">Yes</option>
            <option value="false" selected="true">No</option>
        </param>
        <when value="true">
          <param name="massError" type="float" label="Demultiplex Mass Tolerance" value="10" />
          <param name="massErrorUnits" type="select" label="Units for Demultiplex Mass Tolerance">
            <option value="MZ">mz</option>
            <option value="PPM" selected="true">ppm</option>
          </param>
          <param name="nnlsMaxIter" type="integer" label="Maximum iterations for NNLS solve" value="50"/>
          <param name="nnlsEps" type="float" label="Epsilon value for convergence criterion of NNLS solver" value="1e-10"/>
          <param name="demuxBlockExtra" type="float" label="DemuxBlockExtra" help="Multiplier to expand or reduce the # of spectra considered when demultiplexing. If 0, a fully determined system of equations is built. If > 1.0, the number of rows included in the system is extended DemuxBlockExtra * (# scans in 1 duty cycle)" value="0"/>
          <param name="variableFill" type="boolean" truevalue="true" falsevalue="false" label="Allow fill times to vary for each scan window"/>
          <param name="noSumNormalize" type="boolean" truevalue="true" falsevalue="false" checked="false" label="No sum normalization?" help="After demultiplex solve, scale the sum of the intensities contributed from each of the input windows to match the non-demultiplexed intensity"/>
          <param name="optimization" type="select" label="Optimization" help="Optimizations can be applied when experimental design is known">
            <option value="none" selected="true">None</option>
            <option value="overlap_only">Overlap only</option>
          </param>
          <param name="interpolateRT" type="boolean" truevalue="true" falsevalue="false" checked="True" label="Interpolate scan time"/>
          <param name="noWeighting" type="boolean" truevalue="true" falsevalue="false" checked="false" label="No Weight nearby spectra higher" help="If true, weight the spectra nearby to the input spectrum more heavily in the solve than the outer ones. Weighting is only applied if interpolateRetentionTime is false"/>
          <param name="minWindowSize" type="float" label="Minimum window size" value="0.2"/>
        </when>
        <when value="false" />
      </conditional>

    </section>

    <section name="filtering" title="Scan Inclusion/Exclusion Filters">

      <param name="activation" type="select" label="Filter by Activation">
        <option value="false" selected="true">no</option>
        <option value="ETD">ETD</option>
        <option value="CID">CID</option>
        <option value="SA">SA</option>
        <option value="HCD">HCD</option>
        <option value="BIRD">BIRD</option>
        <option value="ECD">ECD</option>
        <option value="IRMPD">IRMPD</option>
        <option value="PD">PD</option>
        <option value="PSD">PSD</option>
        <option value="PQD">PQD</option>
        <option value="SID">SID</option>
        <option value="SORI">SORI</option>
      </param>

      <repeat name="indices" title="Filter Scan Indices">
        <param name="from" type="integer" label="Filter Scan Index From" value="0" optional="false" />
        <param name="to" type="integer" label="Filter Scan Index To" value="0" optional="true" />
      </repeat>

      <repeat name="scan_numbers" title="Filter Scan Numbers">
        <param name="from" type="integer" label="Filter Scan Number From" value="0" optional="false" />
        <param name="to" type="integer" label="Filter Scan Number To" value="0" optional="true" />
      </repeat>

      <param type="boolean" name="strip_it" label="Strip Ion Trap MS1 Scans" />

      <conditional name="filter_ms_levels">
        <param name="do_ms_level_filter" type="select" label="Filter MS Levels">
            <option value="true">Yes</option>
            <option value="false" selected="true">No</option>
        </param>
        <when value="false" />
        <when value="true">
          <param name="ms_level_from" type="integer" label="Filter MS Level From" value="0" optional="false" />
          <param name="ms_level_to" type="integer" label="Filter MS Level To" value="0" optional="true" />
        </when>
      </conditional>

      <param name="polarity" type="select" label="Filter by Polarity">
        <option value="false" selected="true">no</option>
        <option value="positive">positive</option>
        <option value="negative">negative</option>
      </param>

      <param name="analyzer" type="select" label="Filter by Analyzer">
        <option value="false" selected="true">no</option>
        <option value="quad">Quadrupole</option>
        <option value="orbi">Orbitrap</option>
        <option value="FT">Fourier-transform</option>
        <option value="IT">Ion trap</option>
        <option value="TOF">Time of flight</option>
      </param>
    </section>

    <section name="general_options" title="General Options">
      <param argument="--combineIonMobilitySpectra" type="boolean" truevalue="--combineIonMobilitySpectra" falsevalue="" label="Combine ion mobility spectra" help="When false, each mobility scan is written as a separate spectrum. When true, each retention time point will have a single merged scan. For Bruker TIMS spectra, the ion mobilities will be preserved in a separate binaryDataArray, and for TIMS PASEF MS2s, each precursor will be merged separately." />

      <conditional name="scan_summing">
        <param name="do_scan_summing" type="select" label="Sum adjacent scans" help="Sums MS2 sub-scans whose precursors are similar in the m/z, scan time, and/or ion mobility dimensions. It is useful for some Waters DDA data and Bruker PASEF data, where sub-scans should be summed together to increase the SNR">
            <option value="true">Yes</option>
            <option value="false" selected="true">No</option>
        </param>
        <when value="false" />
        <when value="true">
          <param name="precursorTol" type="float" label="Precursor m/z tolerance" value="0.05" min="0" optional="true" help="Spectra with precursor m/z values with a difference less than this tolerance are summed together." />
          <param name="scanTimeTol" type="float" label="Scan time tolerance" value="10.0" min="0" optional="true" help="Spectra with scan times with a difference less than this tolerance (in seconds) are summed together." />
          <param name="ionMobilityTol" type="float" label="Ion mobility tolerance" value="0.01" min="0" optional="true" help="Spectra with ion mobility values with a difference less than this tolerance are summed together. Only relevant for ion mobility spectra." />
        </when>
      </conditional>

      <param argument="--simAsSpectra" type="boolean" truevalue="--simAsSpectra" falsevalue="" label="SIM as Spectra" help="Write selected ion monitoring as spectra, not chromatograms" />
      <param argument="--srmAsSpectra" type="boolean" truevalue="--srmAsSpectra" falsevalue=""  label="SRM as Spectra" help="Write selected reaction monitoring as spectra, not chromatograms" />
      <param argument="--acceptZeroLengthSpectra" type="boolean" truevalue="--acceptZeroLengthSpectra" falsevalue=""  label="Accept zero-length spectra" help="Some vendor readers have an efficient way of filtering out empty spectra, but it takes more time to open the file" />
      <param argument="--ignoreUnknownInstrumentError" type="boolean" truevalue="--ignoreUnknownInstrumentError" falsevalue=""  label="Ignore unknown instrument error" help="If true, if an instrument cannot be determined from a vendor file, it will not be an error" />

      <conditional name="multi_run_output">
        <param name="do_multi_run_output" type="select" label="Output multiple runs per file" help="Some input types can store multiple runs (samples) in a single file (e.g. WIFF). Each run must be written to a separate output file, so check this option if you want to output all runs for a file (each file will create a dataset collection)">
            <option value="true">Yes</option>
            <option value="false" selected="true">No</option>
        </param>
        <when value="false">
          <param argument="--runIndexSet" type="integer" label="Select a single run for multi-run sources" value="0" min="0" help="For multi-run sources (e.g. WIFF), select only the specified run index (first run is index 0)" />
        </when>
        <when value="true">
          <repeat name="run_index_set" title="Select runs for multi-run sources" help="For multi-run sources (e.g. WIFF), select only the specified run indices">
            <param name="from" type="integer" label="Run Index From" value="0" min="0" optional="false" />
            <param name="to" type="integer" label="Run Index To" value="0" min="0" optional="true" />
          </repeat>
        </when>
      </conditional>
    </section>

    <section name="settings" title="Output Encoding Settings">
      <param type="select" name="mz_encoding" label="m/z Encoding Precision">
        <option value="64" selected="true">64</option>
        <option value="32">32</option>
      </param>
      <param type="select" name="intensity_encoding" label="Intensity Encoding Precision">
        <option value="64">64</option>
        <option value="32" selected="true">32</option>
      </param>
      <param type="select" name="binary_compression" label="Binary data compression">
        <option value="false">None</option>
        <option value="zlib" selected="true">zlib</option>
        <option value="numpressLinearPic">numpressLinear/numpressPic</option>
        <option value="numpressLinearSlof">numpressLinear/numpressSlof</option>
        <option value="numpressLinear">numpressLinear only</option>
        <option value="numpressPic">numpressPic only</option>
        <option value="numpressSlof">numpressSlof only</option>
      </param>
      <param type="boolean" name="gzip_compression" label="Compress output file with gzip" truevalue="true" falsevalue="false" />
    </section>
  </xml>

  <xml name="msconvertOutput">
    <outputs>
      <data format="mzml" name="output" label="${($input.name[:-4] if $input.name.endswith('.tar') else $input.name).rsplit('.',1)[0]}.${output_type}" >
        <filter>general_options['multi_run_output']['do_multi_run_output'] == "false"</filter>
        <change_format>
          <when input="output_type" value="mz5" format="mz5" />
          <when input="output_type" value="mzXML" format="mzxml" />
          <when input="output_type" value="ms2" format="ms2" />
          <when input="output_type" value="mgf" format="mgf" />
        </change_format>
      </data>
      <data format="tsv" name="output_refinement" label="${($input.name[:-4] if $input.name.endswith('.tar') else $input.name).rsplit('.',1)[0]}.mzRefinement.tsv">
        <filter>data_processing['precursor_refinement']['use_mzrefinement'] == "true"</filter>
      </data>
      <collection name="multi_run_output_list" type="list" label="${($input.name[:-4] if $input.name.endswith('.tar') else $input.name).rsplit('.',1)[0]}.${output_type} collection">
        <filter>general_options['multi_run_output']['do_multi_run_output'] == "true"</filter>
        <discover_datasets pattern="__name_and_ext__" directory="outputs" sort_by="designation" />
      </collection>
    </outputs>
  </xml>


  <xml name="msconvert_tests">
    <test expect_num_outputs="1">
      <param name="input" value="small.RAW" ftype="thermo.raw" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="data_processing|peak_picking|pick_peaks" value="true" />
      <param name="data_processing|peak_picking|pick_peaks_algorithm" value="vendor" />
      <param name="data_processing|peak_picking|pick_peaks_ms_levels" value="1-" />
      <output name="output" file="small-peakpicking-vendor-allMS.mzML" ftype="mzml" lines_diff="4" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="ThyroglobMRM000003.d.tar" ftype="brukertdf.d.tar" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="general_options|combineIonMobilitySpectra" value="true" />
      <param name="general_options|scan_summing|do_scan_summing" value="true" />
      <output name="output" file="ThyroglobMRM000003.mzML" ftype="mzml" lines_diff="4" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="MassLynxTest.raw.tar" ftype="watersmasslynx.raw.tar" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <output name="output" file="MassLynxTest.mzML" ftype="mzml" lines_diff="4" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="AgilentMassHunterTest.d.tar" ftype="agilentmasshunter.d.tar" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzXML" />
      <output name="output" file="AgilentMassHunterTest.mzXML" ftype="mzxml" lines_diff="4" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="BrukerBafTest.d.tar" ftype="brukerbaf.d.tar" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="data_processing|peak_picking|pick_peaks" value="true" />
      <param name="data_processing|peak_picking|pick_peaks_algorithm" value="vendor" />
      <param name="data_processing|peak_picking|pick_peaks_ms_levels" value="1-" />
      <output name="output" file="BrukerBafTest.mzML" ftype="mzml" lines_diff="4" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="SciexTest.wiff.tar" ftype="wiff.tar" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzXML" />
      <param name="general_options|multi_run_output|do_multi_run_output" value="false" />
      <param name="general_options|multi_run_output|runIndexSet" value="1" />
      <param name="filtering|indices_0|from" value="0" />
      <param name="filtering|indices_0|to" value="499" />
      <param name="general_options|srmAsSpectra" value="true" />
      <output name="output" file="SciexTest-HPINalone-NE-srmAsSpectra.mzXML" ftype="mzxml" lines_diff="4" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="SciexTest.wiff.tar" ftype="wiff.tar" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="general_options|multi_run_output|do_multi_run_output" value="true" />
      <param name="general_options|multi_run_output|run_index_set_0|from" value="0" />
      <param name="general_options|multi_run_output|run_index_set_0|to" value="1" />
      <output_collection name="multi_run_output_list" type="list">
        <element name="SciexTest-HPINalone" file="SciexTest-HPINalone.mzML" ftype="mzml" lines_diff="4" />
        <element name="SciexTest-HPINalone+NE" file="SciexTest-HPINalone-NE.mzML" ftype="mzml" lines_diff="4" />
      </output_collection>
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="SciexTest.wiff.tar" ftype="wiff.tar" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="general_options|multi_run_output|do_multi_run_output" value="true" />
      <output_collection name="multi_run_output_list" type="list">
        <element name="SciexTest-HPINalone" file="SciexTest-HPINalone.mzML" ftype="mzml" lines_diff="4" />
        <element name="SciexTest-HPINalone+NE" file="SciexTest-HPINalone-NE.mzML" ftype="mzml" lines_diff="4" />
      </output_collection>
    </test>

    <!-- this data file only has profile MS1, so the result is the same -->
    <test expect_num_outputs="1">
      <param name="input" value="small-peakpicking-cwt-allMS.mzML" ftype="mzml" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mz5" />
      <param name="settings|mz_encoding" value="64" />
      <param name="settings|intensity_encoding" value="64" />
      <output name="output" file="small-zlib-64.mz5" compare="sim_size" ftype="mz5" delta="150000" />
    </test>
    <!-- TODO: how to test gzipped output?
    <test>
      <param name="input" value="small-peakpicking-cwt-allMS.mzML" />
      <param name="output_type" value="mzXML" />
      <param name="mz_encoding" value="32" />
      <param name="intensity_encoding" value="32" />
      <param name="settings|binary_compression" value="false" />
      <param name="gzip_compression" value="true" />
      <output name="output" file="small-off-32.mzXML.gz" compare="sim_size" delta="100" />
    </test>
    <test>
      <param name="input" value="small-peakpicking-cwt-allMS.mzML" />
      <param name="output_type" value="mzML" />
      <param name="mz_encoding" value="32" />
      <param name="intensity_encoding" value="32" />
      <param name="settings|binary_compression" value="false" />
      <param name="gzip_compression" value="true" />
      <output name="output" file="small-off-32.mzML.gz" compare="sim_size" delta="100" />
    </test>-->
    <test expect_num_outputs="2">
      <param name="input" value="Rpal_01.mz5" ftype="mz5" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="settings|binary_compression" value="numpressLinearPic" />
      <param name="data_processing|precursor_refinement|use_mzrefinement" value="true" />
      <param name="data_processing|precursor_refinement|input_ident" value="Rpal_01.pepXML" />
      <param name="data_processing|precursor_refinement|thresholdScore" value="mvh" />
      <param name="data_processing|precursor_refinement|thresholdValue" value="40-" />
      <output name="output" file="Rpal_01-mzRefinement.mzML" ftype="mzml" compare="sim_size" delta="0" />
      <output name="output_refinement" file="Rpal_01.pepXML.mzRefinement.tsv" ftype="tsv" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="small.mzML" ftype="mzml" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />

      <param name="data_processing|peak_picking|pick_peaks" value="true" />
      <param name="data_processing|peak_picking|pick_peaks_algorithm" value="cwt" />
      <param name="data_processing|peak_picking|pick_peaks_ms_levels" value="1" />

      <param name="data_processing|thresholds_0|threshold_type" value="count" />
      <param name="data_processing|thresholds_0|value" value="100" />
      <param name="data_processing|thresholds_0|orientation" value="most-intense" />
      <param name="data_processing|thresholds_1|threshold_type" value="absolute" />
      <param name="data_processing|thresholds_1|value" value="1" />
      <param name="data_processing|thresholds_1|orientation" value="most-intense" />

      <param name="data_processing|filter_mz_windows|do_mzwindow_filter" value="true" />
      <param name="data_processing|filter_mz_windows|mz_window_from" value="420" />
      <param name="data_processing|filter_mz_windows|mz_window_to" value="840" />

      <param name="filtering|indices_0|from" value="0" />
      <param name="filtering|indices_0|to" value="20" />
      <param name="filtering|indices_1|from" value="41" />
      <param name="filtering|indices_1|to" value="41" />

      <param name="filtering|filter_ms_levels|do_ms_level_filter" value="true" />
      <param name="filtering|filter_ms_levels|ms_level_from" value="2" />
      <param name="filtering|filter_ms_levels|ms_level_to" value="2" />

      <param name="filtering|scan_numbers_0|from" value="5" />
      <param name="filtering|scan_numbers_0|to" value="25" />
      <param name="filtering|scan_numbers_1|from" value="40" />
      <param name="filtering|scan_numbers_1|to" value="40" />

      <param name="data_processing|ms2deisotope" value="true" />

      <param name="data_processing|ms2denoise|denoise" value="true" />
      <param name="data_processing|ms2denoise|num_peaks" value="10" />
      <param name="data_processing|ms2denoise|window_width" value="40" />
      <param name="data_processing|ms2denoise|relax" value="false" />

      <param name="data_processing|charge_state_calculation|charge_state_calculation_method" value="predictor" />
      <param name="data_processing|charge_state_calculation|predictor_overrideExistingCharge" value="true" />
      <param name="data_processing|charge_state_calculation|minMultipleCharge" value="2" />
      <param name="data_processing|charge_state_calculation|maxMultipleCharge" value="5" />
      <param name="data_processing|charge_state_calculation|singleChargeFractionTIC" value="0.95" />
      <param name="data_processing|charge_state_calculation|maxKnownCharge" value="8" />

      <param name="settings|mz_encoding" value="32" />
      <param name="settings|intensity_encoding" value="32" />

      <param name="settings|binary_compression" value="numpressLinearPic" />
      <output name="output" file="small-composite-test.mzML" ftype="mzml" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="small-peakpicking-cwt-allMS.mzML" ftype="mzml" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="settings|binary_compression" value="numpressLinearPic" />
      <param name="data_processing|charge_state_calculation|charge_state_calculation_method" value="turbocharger" />
      <param name="data_processing|charge_state_calculation|minCharge" value="1" />
      <param name="data_processing|charge_state_calculation|maxCharge" value="5" />
      <param name="data_processing|charge_state_calculation|precursorsBefore" value="1" />
      <param name="data_processing|charge_state_calculation|precursorsAfter" value="1" />
      <param name="data_processing|charge_state_calculation|halfIsoWidth" value="1.5" />
      <param name="data_processing|charge_state_calculation|defaultMinCharge" value="1" />
      <param name="data_processing|charge_state_calculation|defaultMaxCharge" value="5" />
      <param name="filtering|strip_it" value="true" />
      <output name="output" file="small-composite-test-2.mzML" ftype="mzml" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="small-peakpicking-cwt-allMS.mzML" ftype="mzml" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="filtering|activation" value="CID" />
      <param name="settings|binary_compression" value="numpressLinearPic" />
      <output name="output" file="small-activation.mzML" lines_diff="114" ftype="mzml" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="small-peakpicking-cwt-allMS.mzML" ftype="mzml" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="filtering|polarity" value="positive" />
      <param name="settings|binary_compression" value="numpressLinearPic" />
      <output name="output" file="small-polarity-filter.mzML" lines_diff="114" ftype="mzml" />
    </test>
    <test expect_num_outputs="1">
      <param name="input" value="D100930_yeast_SCX10S_rak_ft8E_pc_01.mz5" ftype="mz5" />
      <param name="license_agreement" value="true" />
      <param name="output_type" value="mzML" />
      <param name="data_processing|etd_filtering|do_etd_filtering" value="true" />
      <param name="data_processing|etd_filtering|remove_precursor" value="true" />
      <param name="data_processing|etd_filtering|remove_charge_reduced" value="true" />
      <param name="data_processing|etd_filtering|remove_neutral_loss" value="false" />
      <param name="data_processing|etd_filtering|blanket_removal" value="false" />
      <param name="data_processing|etd_filtering|matching_tolerance" value="50" />
      <param name="data_processing|etd_filtering|matching_tolerance_units" value="PPM" />
      <param name="settings|binary_compression" value="numpressLinearPic" />
      <output name="output" file="D100930_yeast_SCX10S_rak_ft8E_pc_01-etdfilter.mzML" ftype="mzml" />
    </test>
    <!--<test>
      <param name="input" value="small.mzML" />
      <param name="output_type" value="mzML" />
      <param name="settings|binary_compression" value="numpressLinearPic" />
      <output name="output" file="small-deisotope-poisson.mzML" />
    </test>-->
  </xml>
  <xml name="citations">
    <citations>
        <citation type="doi">10.1093/bioinformatics/btn323</citation>
        <citation type="bibtex">@misc{toolsGalaxyP, author = {Chilton, J, Chambers MC, et al.}, title = {Galaxy Proteomics Tools}, publisher = {GitHub}, journal = {GitHub repository},
                                      year = {2015}, url = {https://github.com/galaxyproteomics/tools-galaxyp}}</citation> <!-- TODO: fix substitution of commit ", commit = {$sha1$}" -->
    </citations>
  </xml>

</macros>
